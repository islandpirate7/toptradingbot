"""
Backtest Seasonal Strategy

This script runs a backtest using the configuration generated by the seasonality analyzer.
It leverages the existing combined strategy framework but applies it to the seasonally-selected stocks.
"""

import os
import sys
import logging
import yaml
import json
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
from alpaca.data.historical import StockHistoricalDataClient
from alpaca.data.requests import StockBarsRequest
from alpaca.data.timeframe import TimeFrame
from typing import Dict, List, Tuple, Optional, Union
import argparse

# Import our strategy modules
from combined_strategy import CombinedStrategy, MarketRegime
from backtest_combined_strategy import BacktestCombinedStrategy, BacktestResults

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

def parse_args():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(description='Backtest seasonal strategy')
    
    parser.add_argument('--config', type=str, default='configuration_seasonal_strategy.yaml',
                       help='Path to configuration file')
    
    parser.add_argument('--start-date', type=str,
                       help='Backtest start date (YYYY-MM-DD), defaults to config value')
    
    parser.add_argument('--end-date', type=str,
                       help='Backtest end date (YYYY-MM-DD), defaults to config value')
    
    parser.add_argument('--output', type=str, default='seasonal_backtest_results.json',
                       help='Output file for backtest results')
    
    parser.add_argument('--plot', action='store_true',
                       help='Generate performance plots')
    
    return parser.parse_args()

def print_quarterly_comparison(results: BacktestResults):
    """Print quarterly performance comparison"""
    if not hasattr(results, 'equity_curve') or results.equity_curve is None:
        logging.warning("No equity curve data available for quarterly comparison")
        return
    
    # Convert equity curve to DataFrame if it's a Series
    if isinstance(results.equity_curve, pd.Series):
        equity_df = results.equity_curve.to_frame('equity')
    else:
        equity_df = results.equity_curve
    
    # Ensure we have a datetime index
    if not isinstance(equity_df.index, pd.DatetimeIndex):
        equity_df.index = pd.to_datetime(equity_df.index)
    
    # Get quarterly returns
    equity_df['quarter'] = equity_df.index.to_period('Q')
    quarterly_returns = {}
    
    for quarter, group in equity_df.groupby('quarter'):
        start_equity = group['equity'].iloc[0]
        end_equity = group['equity'].iloc[-1]
        quarterly_return = ((end_equity / start_equity) - 1) * 100
        quarterly_returns[str(quarter)] = quarterly_return
    
    # Print quarterly returns
    print("\n===== QUARTERLY RETURNS =====")
    for quarter, ret in quarterly_returns.items():
        print(f"{quarter}: {ret:.2f}%")
    
    # Calculate average quarterly return
    avg_quarterly_return = np.mean(list(quarterly_returns.values()))
    print(f"\nAverage Quarterly Return: {avg_quarterly_return:.2f}%")
    
    # Calculate quarterly win rate
    wins = sum(1 for ret in quarterly_returns.values() if ret > 0)
    total = len(quarterly_returns)
    win_rate = (wins / total) * 100 if total > 0 else 0
    print(f"Quarterly Win Rate: {win_rate:.2f}% ({wins}/{total})")

def main():
    """Main function to run the backtest"""
    args = parse_args()
    
    # Load configuration
    try:
        with open(args.config, 'r') as f:
            config = yaml.safe_load(f)
            logging.info(f"Loaded configuration from {args.config}")
    except Exception as e:
        logging.error(f"Error loading configuration: {e}")
        return
    
    # Set dates from args if provided, otherwise use config
    start_date = args.start_date if args.start_date else config['general']['backtest_start_date']
    end_date = args.end_date if args.end_date else config['general']['backtest_end_date']
    
    # Initialize backtest
    backtest = BacktestCombinedStrategy(config)
    
    # Run backtest
    logging.info(f"Running backtest from {start_date} to {end_date}")
    results = backtest.run(start_date, end_date)
    
    # Print results
    print("\n===== BACKTEST RESULTS =====")
    print(f"Initial Capital: ${results.initial_capital:.2f}")
    print(f"Final Equity: ${results.final_equity:.2f}")
    print(f"Total Return: {results.total_return_pct:.2f}%")
    print(f"Win Rate: {results.win_rate:.2f}%")
    print(f"Profit Factor: {results.profit_factor:.2f}")
    print(f"Total Trades: {results.total_trades}")
    print(f"Average Trade Return: {results.avg_trade_return_pct:.2f}%")
    print(f"Max Drawdown: {results.max_drawdown_pct:.2f}%")
    print(f"Sharpe Ratio: {results.sharpe_ratio:.2f}")
    
    # Print quarterly comparison
    print_quarterly_comparison(results)
    
    # Print performance by market regime
    print("\n===== PERFORMANCE BY MARKET REGIME =====")
    for regime, stats in results.regime_performance.items():
        print(f"{regime}:")
        print(f"  Return: ${stats['return']:.2f}")
        print(f"  Win Rate: {stats['win_rate']:.2f}%")
        print(f"  Trades: {stats['trades']}")
        print(f"  Average Return: {stats['avg_return']:.2f}%")
    
    # Print performance by strategy
    print("\n===== PERFORMANCE BY STRATEGY =====")
    for strategy, stats in results.strategy_performance.items():
        print(f"{strategy}:")
        print(f"  Return: ${stats['return']:.2f}")
        print(f"  Win Rate: {stats['win_rate']:.2f}%")
        print(f"  Trades: {stats['trades']}")
        print(f"  Average Return: {stats['avg_return']:.2f}%")
    
    # Save results to file
    results_dict = {
        'initial_capital': results.initial_capital,
        'final_equity': results.final_equity,
        'total_return_pct': results.total_return_pct,
        'win_rate': results.win_rate,
        'profit_factor': results.profit_factor,
        'total_trades': results.total_trades,
        'avg_trade_return_pct': results.avg_trade_return_pct,
        'max_drawdown_pct': results.max_drawdown_pct,
        'sharpe_ratio': results.sharpe_ratio,
        'regime_performance': results.regime_performance,
        'strategy_performance': results.strategy_performance
    }
    
    with open(args.output, 'w') as f:
        json.dump(results_dict, f, indent=2)
        logging.info(f"Saved results to {args.output}")
    
    # Generate plots if requested
    if args.plot and hasattr(results, 'equity_curve') and results.equity_curve is not None:
        # Plot equity curve
        plt.figure(figsize=(12, 6))
        plt.plot(results.equity_curve)
        plt.title('Equity Curve')
        plt.xlabel('Date')
        plt.ylabel('Equity ($)')
        plt.grid(True)
        plt.savefig('seasonal_equity_curve.png')
        logging.info("Generated equity curve plot: seasonal_equity_curve.png")
        
        # Plot drawdown
        if hasattr(results, 'drawdown') and results.drawdown is not None:
            plt.figure(figsize=(12, 6))
            plt.plot(results.drawdown * 100)
            plt.title('Drawdown')
            plt.xlabel('Date')
            plt.ylabel('Drawdown (%)')
            plt.grid(True)
            plt.savefig('seasonal_drawdown.png')
            logging.info("Generated drawdown plot: seasonal_drawdown.png")

if __name__ == "__main__":
    main()
