import pandas as pd
import yfinance as yf
import numpy as np
import datetime as dt
import logging
import time
import json
import os
from typing import Dict, List, Tuple, Optional, Union, Any
import matplotlib.pyplot as plt
import mplfinance as mpf
from dataclasses import dataclass, field
import threading
import queue
from concurrent.futures import ThreadPoolExecutor
from enum import Enum
from abc import ABC, abstractmethod
import copy
import traceback
import math

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("multi_strategy_system.log"),
        logging.StreamHandler(),
        logging.FileHandler('trading_system.log', mode='w')
    ]
)
logger = logging.getLogger("MultiStrategySystem")

# Set up additional loggers for strategies
strategy_logger = logging.getLogger("Strategy")
strategy_logger.setLevel(logging.DEBUG)
for handler in logging.root.handlers:
    strategy_logger.addHandler(handler)

# ===== Enums and Constants =====

class MarketRegime(Enum):
    """Market regime classification"""
    TRENDING_BULLISH = "TRENDING_BULLISH"
    TRENDING_BEARISH = "TRENDING_BEARISH"
    RANGE_BOUND = "RANGE_BOUND"
    HIGH_VOLATILITY = "HIGH_VOLATILITY"
    LOW_VOLATILITY = "LOW_VOLATILITY"
    BULLISH_BREAKOUT = "BULLISH_BREAKOUT"
    BEARISH_BREAKDOWN = "BEARISH_BREAKDOWN"
    CONSOLIDATION = "CONSOLIDATION"
    UNKNOWN = "UNKNOWN"

class TradeDirection(Enum):
    """Trade direction"""
    LONG = "LONG"
    SHORT = "SHORT"
    NEUTRAL = "NEUTRAL"

class TimeFrame(Enum):
    """Timeframes for data analysis"""
    M1 = "1min"
    M5 = "5min"
    M15 = "15min"
    M30 = "30min"
    H1 = "1hour"
    H4 = "4hour"
    D1 = "1day"

class SignalStrength(Enum):
    """Signal strength classification"""
    STRONG_BUY = 3
    MODERATE_BUY = 2
    WEAK_BUY = 1
    NEUTRAL = 0
    WEAK_SELL = -1
    MODERATE_SELL = -2
    STRONG_SELL = -3

# ===== Data Structures =====

@dataclass
class CandleData:
    """Represents a single OHLCV candle"""
    timestamp: dt.datetime
    open: float
    high: float
    low: float
    close: float
    volume: int
    
    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        return {
            "timestamp": self.timestamp,
            "open": self.open,
            "high": self.high,
            "low": self.low,
            "close": self.close,
            "volume": self.volume
        }

@dataclass
class StockConfig:
    """Configuration for individual stocks"""
    symbol: str
    max_position_size: int            # Maximum position size
    min_position_size: int            # Minimum position size
    max_risk_per_trade_pct: float     # Maximum risk per trade as percentage of account
    min_volume: int                   # Minimum volume to consider valid
    avg_daily_volume: int = 0         # Average daily volume (calculated dynamically)
    beta: float = 1.0                 # Stock beta (volatility relative to market)
    sector: str = ""                  # Stock sector
    industry: str = ""                # Stock industry
    
    # Strategy-specific parameters
    mean_reversion_params: Dict = field(default_factory=dict)
    trend_following_params: Dict = field(default_factory=dict)
    volatility_breakout_params: Dict = field(default_factory=dict)
    gap_trading_params: Dict = field(default_factory=dict)

@dataclass
class Signal:
    """Trading signal generated by a strategy"""
    timestamp: dt.datetime
    symbol: str
    strategy: str
    direction: TradeDirection
    strength: SignalStrength
    entry_price: float
    stop_loss: float
    take_profit: Optional[float] = None
    expiration: Optional[dt.datetime] = None
    metadata: Dict = field(default_factory=dict)
    
    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        return {
            "timestamp": self.timestamp,
            "symbol": self.symbol,
            "strategy": self.strategy,
            "direction": self.direction.value,
            "strength": self.strength.value,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "expiration": self.expiration,
            "metadata": self.metadata
        }

@dataclass
class PositionState:
    """Current state of a position"""
    symbol: str
    direction: TradeDirection
    entry_price: float
    stop_loss: float
    take_profit: Optional[float]
    position_size: int
    entry_time: dt.datetime
    exit_price: Optional[float] = None
    exit_time: Optional[dt.datetime] = None
    is_active: bool = True
    strategy: str = ""
    current_price: Optional[float] = None
    unrealized_pnl: float = 0.0
    realized_pnl: float = 0.0
    metadata: Dict = field(default_factory=dict)
    
    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        return {
            "symbol": self.symbol,
            "direction": self.direction.value,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "position_size": self.position_size,
            "entry_time": self.entry_time,
            "exit_price": self.exit_price,
            "exit_time": self.exit_time,
            "is_active": self.is_active,
            "strategy": self.strategy,
            "current_price": self.current_price,
            "unrealized_pnl": self.unrealized_pnl,
            "realized_pnl": self.realized_pnl
        }

@dataclass
class MarketState:
    """Current state of the market"""
    timestamp: dt.datetime
    regime: MarketRegime
    vix: float
    market_adx: float
    trending_strength: float  # 0-1 scale
    range_bound_strength: float  # 0-1 scale
    volatility_strength: float  # 0-1 scale
    market_trend: TradeDirection
    sector_performance: Dict[str, float] = field(default_factory=dict)
    breadth_indicators: Dict[str, float] = field(default_factory=dict)  # advance/decline, etc.
    intermarket_indicators: Dict[str, float] = field(default_factory=dict)  # bonds/stocks correlation, etc.
    economic_indicators: Dict[str, float] = field(default_factory=dict)  # economic data
    sentiment_indicators: Dict[str, float] = field(default_factory=dict)  # market sentiment
    regime_change_probability: float = 0.0  # Probability of regime change
    sub_regime: str = ""  # More specific classification within the main regime
    
    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        base_dict = {
            "timestamp": self.timestamp,
            "regime": self.regime.value,
            "vix": self.vix,
            "market_adx": self.market_adx,
            "trending_strength": self.trending_strength,
            "range_bound_strength": self.range_bound_strength,
            "volatility_strength": self.volatility_strength,
            "market_trend": self.market_trend.value,
            "sector_performance": self.sector_performance,
            "regime_change_probability": self.regime_change_probability,
            "sub_regime": self.sub_regime
        }
        
        # Add new indicator dictionaries if they have values
        if self.breadth_indicators:
            base_dict["breadth_indicators"] = self.breadth_indicators
        if self.intermarket_indicators:
            base_dict["intermarket_indicators"] = self.intermarket_indicators
        if self.economic_indicators:
            base_dict["economic_indicators"] = self.economic_indicators
        if self.sentiment_indicators:
            base_dict["sentiment_indicators"] = self.sentiment_indicators
            
        return base_dict

@dataclass
class StrategyPerformance:
    """Performance metrics for a strategy"""
    strategy: str
    win_rate: float = 0.0
    profit_factor: float = 0.0
    avg_gain: float = 0.0
    avg_loss: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    total_pnl: float = 0.0
    performance_by_regime: Dict[str, float] = field(default_factory=dict)
    
    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        return {
            "strategy": self.strategy,
            "win_rate": self.win_rate,
            "profit_factor": self.profit_factor,
            "avg_gain": self.avg_gain,
            "avg_loss": self.avg_loss,
            "max_drawdown": self.max_drawdown,
            "sharpe_ratio": self.sharpe_ratio,
            "total_trades": self.total_trades,
            "winning_trades": self.winning_trades,
            "losing_trades": self.losing_trades,
            "total_pnl": self.total_pnl,
            "performance_by_regime": self.performance_by_regime
        }

@dataclass
class SystemConfig:
    """System configuration"""
    stocks: List[StockConfig]
    initial_capital: float
    max_open_positions: int
    max_positions_per_symbol: int
    max_correlated_positions: int
    max_sector_exposure_pct: float
    max_portfolio_risk_daily_pct: float
    strategy_weights: Dict[str, float]  # Initial weights for strategies
    rebalance_interval: dt.timedelta
    data_lookback_days: int
    market_hours_start: dt.time
    market_hours_end: dt.time
    enable_auto_trading: bool
    backtesting_mode: bool
    data_source: str
    api_key: Optional[str] = None
    api_secret: Optional[str] = None

@dataclass
class BacktestResult:
    """Results from backtesting"""
    start_date: dt.date
    end_date: dt.date
    initial_capital: float
    final_capital: float
    total_return_pct: float
    annualized_return_pct: float
    sharpe_ratio: float
    max_drawdown_pct: float
    win_rate: float
    profit_factor: float
    total_trades: int
    strategy_performance: Dict[str, StrategyPerformance]
    monthly_returns: Dict[str, float]
    equity_curve: List[Tuple[dt.datetime, float]]
    drawdown_curve: List[Tuple[dt.datetime, float]]
    trade_history: List[Dict]
    
    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        return {
            "start_date": self.start_date.isoformat(),
            "end_date": self.end_date.isoformat(),
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "total_return_pct": self.total_return_pct,
            "annualized_return_pct": self.annualized_return_pct,
            "sharpe_ratio": self.sharpe_ratio,
            "max_drawdown_pct": self.max_drawdown_pct,
            "win_rate": self.win_rate,
            "profit_factor": self.profit_factor,
            "total_trades": self.total_trades,
            "strategy_performance": {k: v.to_dict() for k, v in self.strategy_performance.items()},
            "monthly_returns": self.monthly_returns,
            "equity_curve": [(t.isoformat(), v) for t, v in self.equity_curve],
            "drawdown_curve": [(t.isoformat(), v) for t, v in self.drawdown_curve],
            "trade_history": self.trade_history
        }

# ===== Strategy Abstract Base Class =====

class Strategy(ABC):
    """Abstract base class for trading strategies"""
    
    def __init__(self, name: str, config: Dict):
        """Initialize strategy with configuration"""
        self.name = name
        self.config = config
        self.logger = logging.getLogger(f"Strategy.{name}")
        self.performance = StrategyPerformance(strategy=name)
    
    def get_param(self, name: str, default=None):
        """Get a parameter value with a default fallback"""
        return self.config.get(name, default)
    
    def update_performance(self, trade: Dict):
        """Update strategy performance metrics based on a completed trade"""
        self.performance.total_trades += 1
        
        # Update win/loss count and PnL
        pnl = trade.get('realized_pnl', 0)
        self.performance.total_pnl += pnl
        
        if pnl > 0:
            self.performance.winning_trades += 1
            self.performance.avg_gain = ((self.performance.avg_gain * (self.performance.winning_trades - 1)) + pnl) / self.performance.winning_trades
        else:
            self.performance.losing_trades += 1
            self.performance.avg_loss = ((self.performance.avg_loss * (self.performance.losing_trades - 1)) + pnl) / self.performance.losing_trades
        
        # Calculate win rate
        if self.performance.total_trades > 0:
            self.performance.win_rate = (self.performance.winning_trades / self.performance.total_trades) * 100
        
        # Calculate profit factor
        if self.performance.losing_trades > 0 and self.performance.avg_loss != 0:
            self.performance.profit_factor = (self.performance.winning_trades * self.performance.avg_gain) / (self.performance.losing_trades * abs(self.performance.avg_loss))
        
        # Update performance by market regime if available
        regime = trade.get('market_regime')
        if regime:
            if regime not in self.performance.performance_by_regime:
                self.performance.performance_by_regime[regime] = 0
            self.performance.performance_by_regime[regime] += pnl
    
    @abstractmethod
    def generate_signals(self, 
                         symbol: str, 
                         candles: List[CandleData],
                         stock_config: StockConfig,
                         market_state: MarketState) -> List[Signal]:
        """Generate trading signals for a symbol"""
        pass
    
    @abstractmethod
    def calculate_stop_loss(self, 
                           current_price: float, 
                           direction: TradeDirection, 
                           candles: List[CandleData]) -> float:
        """Calculate stop loss price based on strategy logic"""
        pass
    
    @abstractmethod
    def calculate_take_profit(self, 
                             direction: TradeDirection,
                             entry_price: float,
                             stop_loss: float,
                             candles: List[CandleData],
                             stock_config: StockConfig) -> float:
        """Calculate take profit price based on strategy logic"""
        pass
    
    @abstractmethod
    def should_exit_position(self, 
                            position: PositionState,
                            candles: List[CandleData],
                            market_state: MarketState) -> Tuple[bool, str]:
        """Check if a position should be exited"""
        pass
    
    @abstractmethod
    def calculate_regime_weight(self, market_state: MarketState) -> float:
        """Calculate weight of this strategy based on market regime"""
        # Implement in derived classes for specific regime weighting
        return 1.0

class MeanReversionStrategy(Strategy):
    """Mean reversion strategy using Bollinger Bands and RSI"""
    
    def __init__(self, config: Dict):
        super().__init__("MeanReversion", config)
        # Strategy parameters are now accessed via get_param method
    
    def generate_signals(self, 
                        symbol: str, 
                        candles: List[CandleData],
                        stock_config: StockConfig,
                        market_state: MarketState) -> List[Signal]:
        """Generate mean reversion signals"""
        signals = []
        
        # Log the parameters being used for this strategy
        strategy_logger.info(f"MeanReversion generating signals for {symbol} with {len(candles)} candles")
        strategy_logger.info(f"Parameters: bb_period={self.get_param('bb_period', 20)}, bb_std_dev={self.get_param('bb_std_dev', 2.0)}, "
                        f"rsi_period={self.get_param('rsi_period', 14)}, rsi_overbought={self.get_param('rsi_overbought', 70)}, "
                        f"rsi_oversold={self.get_param('rsi_oversold', 30)}, min_reversal_candles={self.get_param('min_reversal_candles', 2)}")
        
        # Log the first and last few candles to understand the data
        if len(candles) > 0:
            strategy_logger.info(f"First 3 candles for {symbol}: {[f'{c.timestamp}: O={c.open:.2f}, H={c.high:.2f}, L={c.low:.2f}, C={c.close:.2f}' for c in candles[:3]]}")
            strategy_logger.info(f"Last 3 candles for {symbol}: {[f'{c.timestamp}: O={c.open:.2f}, H={c.high:.2f}, L={c.low:.2f}, C={c.close:.2f}' for c in candles[-3:]]}")
        
        if len(candles) < 30:  # Need at least 30 candles for calculations
            strategy_logger.warning(f"Not enough candles for {symbol}: {len(candles)}")
            return signals
        
        # Calculate Bollinger Bands
        bb_period = self.get_param('bb_period', 20)
        bb_std_dev = self.get_param('bb_std_dev', 2.0)
        
        # Extract close prices
        close_prices = [candle.close for candle in candles]
        strategy_logger.debug(f"Close prices for {symbol}: {close_prices[-5:]}")
        
        # Calculate SMA for Bollinger Bands
        sma = sum(close_prices[-bb_period:]) / bb_period
        
        # Calculate standard deviation
        variance = sum((price - sma) ** 2 for price in close_prices[-bb_period:]) / bb_period
        std_dev = math.sqrt(variance)
        
        # Calculate Bollinger Bands
        upper_band = sma + (bb_std_dev * std_dev)
        lower_band = sma - (bb_std_dev * std_dev)
        
        strategy_logger.info(f"{symbol} Bollinger Bands: SMA={sma:.2f}, Upper={upper_band:.2f}, Lower={lower_band:.2f}, Last Close={close_prices[-1]:.2f}")
        
        # Calculate RSI
        rsi_period = self.get_param('rsi_period', 14)
        rsi_overbought = self.get_param('rsi_overbought', 70)
        rsi_oversold = self.get_param('rsi_oversold', 30)
        
        # Calculate price changes
        changes = [close_prices[i] - close_prices[i-1] for i in range(1, len(close_prices))]
        
        # Calculate gains and losses
        gains = [change if change > 0 else 0 for change in changes]
        losses = [abs(change) if change < 0 else 0 for change in changes]
        
        # Calculate average gain and average loss
        avg_gain = sum(gains[-rsi_period:]) / rsi_period
        avg_loss = sum(losses[-rsi_period:]) / rsi_period
        
        # Calculate RS and RSI
        if avg_loss == 0:
            rsi = 100
        else:
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
        
        strategy_logger.info(f"{symbol} RSI: {rsi:.2f}, Overbought: {rsi_overbought}, Oversold: {rsi_oversold}")
        
        # Check for mean reversion signals
        current_price = candles[-1].close
        min_reversal_candles = self.get_param('min_reversal_candles', 2)
        require_reversal = self.get_param('require_reversal', True)
        
        # Check for oversold condition (buy signal)
        if current_price < lower_band * 1.02 and rsi < rsi_oversold * 1.1:  # Stricter conditions
            strategy_logger.info(f"Potential BUY signal for {symbol}: Price near lower band ({current_price:.2f} vs {lower_band:.2f}) and RSI near oversold ({rsi:.2f} vs {rsi_oversold})")
            
            # Check for price reversal (min_reversal_candles consecutive higher lows)
            if require_reversal:
                reversal = True
                for i in range(1, min_reversal_candles + 1):
                    if i >= len(candles) or candles[-i].low <= candles[-i-1].low:
                        strategy_logger.info(f"Reversal check failed at candle -{i}: {candles[-i].low:.2f} <= {candles[-i-1].low:.2f}")
                        reversal = False
                        break
                    else:
                        strategy_logger.info(f"Reversal check passed at candle -{i}: {candles[-i].low:.2f} > {candles[-i-1].low:.2f}")
            
            if not reversal:
                strategy_logger.info(f"No BUY signal for {symbol}: Price near lower band and RSI near oversold, but no reversal pattern")
                return signals
        
            # Check for volume confirmation
            volume_increase = candles[-1].volume > sum([c.volume for c in candles[-6:-1]]) / 5  # Volume above 5-day average
            if not volume_increase:
                strategy_logger.info(f"No BUY signal for {symbol}: Price near lower band and RSI near oversold, but no volume confirmation")
                return signals
            
            strategy_logger.info(f"BUY SIGNAL for {symbol}: Price near lower band ({current_price:.2f} vs {lower_band:.2f}) and RSI near oversold ({rsi:.2f} vs {rsi_oversold})")
            
            # Calculate more realistic stop loss and take profit
            atr = self._calculate_atr(candles, 14)  # Use 14-day ATR
            stop_loss_atr_multiplier = self.get_param('stop_loss_atr', 2.0)
            take_profit_atr_multiplier = self.get_param('take_profit_atr', 3.0)
            stop_loss = current_price - (atr * stop_loss_atr_multiplier)
            take_profit = current_price + (atr * take_profit_atr_multiplier)
            
            # Determine signal strength based on RSI and price deviation
            rsi_strength = (rsi_oversold - rsi) / rsi_oversold
            price_strength = (lower_band - current_price) / lower_band
            
            if rsi_strength > 0.2 and price_strength > 0.05:
                strength = SignalStrength.STRONG_BUY
            elif rsi_strength > 0.1 or price_strength > 0.02:
                strength = SignalStrength.MODERATE_BUY
            else:
                strength = SignalStrength.WEAK_BUY
            
            signal = Signal(
                symbol=symbol,
                direction=TradeDirection.LONG,
                strategy=self.name,
                entry_price=current_price,
                stop_loss=stop_loss,
                take_profit=take_profit,
                timestamp=candles[-1].timestamp,
                strength=strength,
                expiration=candles[-1].timestamp + dt.timedelta(days=3)
            )
            signals.append(signal)
        else:
            strategy_logger.info(f"No BUY signal for {symbol}: Price not near lower band or RSI not near oversold")
            strategy_logger.info(f"  Current price: {current_price:.2f}, Lower band: {lower_band:.2f}, RSI: {rsi:.2f}, RSI oversold: {rsi_oversold}")
            strategy_logger.info(f"  Conditions: price < lower_band * 1.02 = {current_price < lower_band * 1.02}, rsi < rsi_oversold * 1.1 = {rsi < rsi_oversold * 1.1}")
        
        # Check for overbought condition (sell signal)
        if current_price > upper_band * 0.98 and rsi > rsi_overbought * 0.9:  # Stricter conditions
            strategy_logger.info(f"Potential SELL signal for {symbol}: Price near upper band ({current_price:.2f} vs {upper_band:.2f}) and RSI near overbought ({rsi:.2f} vs {rsi_overbought})")
            
            # Check for price reversal (min_reversal_candles consecutive lower highs)
            if require_reversal:
                reversal = True
                for i in range(1, min_reversal_candles + 1):
                    if i >= len(candles) or candles[-i].high >= candles[-i-1].high:
                        strategy_logger.info(f"Reversal check failed at candle -{i}: {candles[-i].high:.2f} >= {candles[-i-1].high:.2f}")
                        reversal = False
                        break
                    else:
                        strategy_logger.info(f"Reversal check passed at candle -{i}: {candles[-i].high:.2f} < {candles[-i-1].high:.2f}")
            
            if not reversal:
                strategy_logger.info(f"No SELL signal for {symbol}: Price near upper band and RSI near overbought, but no reversal pattern")
                return signals
        
            # Check for volume confirmation
            volume_increase = candles[-1].volume > sum([c.volume for c in candles[-6:-1]]) / 5  # Volume above 5-day average
            if not volume_increase:
                strategy_logger.info(f"No SELL signal for {symbol}: Price near upper band and RSI near overbought, but no volume confirmation")
                return signals
            
            strategy_logger.info(f"SELL SIGNAL for {symbol}: Price near upper band ({current_price:.2f} vs {upper_band:.2f}) and RSI near overbought ({rsi:.2f} vs {rsi_overbought})")
            
            # Calculate more realistic stop loss and take profit
            atr = self._calculate_atr(candles, 14)  # Use 14-day ATR
            stop_loss_atr_multiplier = self.get_param('stop_loss_atr', 2.0)
            take_profit_atr_multiplier = self.get_param('take_profit_atr', 3.0)
            stop_loss = current_price + (atr * stop_loss_atr_multiplier)
            take_profit = current_price - (atr * take_profit_atr_multiplier)
            
            # Determine signal strength based on RSI and price deviation
            rsi_strength = (rsi - rsi_overbought) / (100 - rsi_overbought)
            price_strength = (current_price - upper_band) / upper_band
            
            if rsi_strength > 0.2 and price_strength > 0.05:
                strength = SignalStrength.STRONG_SELL
            elif rsi_strength > 0.1 or price_strength > 0.02:
                strength = SignalStrength.MODERATE_SELL
            else:
                strength = SignalStrength.WEAK_SELL
            
            signal = Signal(
                symbol=symbol,
                direction=TradeDirection.SHORT,
                strategy=self.name,
                entry_price=current_price,
                stop_loss=stop_loss,
                take_profit=take_profit,
                timestamp=candles[-1].timestamp,
                strength=strength,
                expiration=candles[-1].timestamp + dt.timedelta(days=3)
            )
            signals.append(signal)
        else:
            strategy_logger.info(f"No SELL signal for {symbol}: Price not near upper band or RSI not near overbought")
            strategy_logger.info(f"  Current price: {current_price:.2f}, Upper band: {upper_band:.2f}, RSI: {rsi:.2f}, RSI overbought: {rsi_overbought}")
            strategy_logger.info(f"  Conditions: price > upper_band * 0.98 = {current_price > upper_band * 0.98}, rsi > rsi_overbought * 0.9 = {rsi > rsi_overbought * 0.9}")
        
        return signals
    
    def _calculate_atr(self, candles: List[CandleData], period: int) -> float:
        """Calculate Average True Range for a list of candles"""
        if len(candles) < period + 1:
            return 0.0
        
        true_ranges = []
        for i in range(1, len(candles)):
            high = candles[i].high
            low = candles[i].low
            prev_close = candles[i-1].close
            
            tr1 = high - low
            tr2 = abs(high - prev_close)
            tr3 = abs(low - prev_close)
            
            true_range = max(tr1, tr2, tr3)
            true_ranges.append(true_range)
        
        # Use the last 'period' true ranges
        recent_true_ranges = true_ranges[-period:]
        
        if not recent_true_ranges:
            return 0.0
        
        return sum(recent_true_ranges) / len(recent_true_ranges)

class TrendFollowingStrategy(Strategy):
    """Trend following strategy using moving average crossovers"""
    
    def __init__(self, config: Dict):
        super().__init__("TrendFollowing", config)
        # Strategy parameters are now accessed via get_param method
    
    def generate_signals(self, 
                        symbol: str, 
                        candles: List[CandleData],
                        stock_config: StockConfig,
                        market_state: MarketState) -> List[Signal]:
        """Generate trend following signals"""
        signals = []
        
        # Get parameters from config
        fast_ema_period = self.get_param("fast_ema_period", 9)
        slow_ema_period = self.get_param("slow_ema_period", 21)
        adx_period = self.get_param("adx_period", 14)
        adx_threshold = self.get_param("adx_threshold", 25)
        macd_fast = self.get_param("macd_fast", 12)
        macd_slow = self.get_param("macd_slow", 26)
        macd_signal = self.get_param("macd_signal", 9)
        
        if len(candles) < max(slow_ema_period, adx_period, macd_slow + macd_signal) + 10:
            # Not enough data for calculation
            return signals
        
        # Convert candles to DataFrame for easier calculation
        df = pd.DataFrame([candle.to_dict() for candle in candles])
        df.set_index('timestamp', inplace=True)
        
        # Calculate EMAs
        df['fast_ema'] = df['close'].ewm(span=fast_ema_period, adjust=False).mean()
        df['slow_ema'] = df['close'].ewm(span=slow_ema_period, adjust=False).mean()
        
        # Calculate MACD
        df['macd'] = df['close'].ewm(span=macd_fast, adjust=False).mean() - df['close'].ewm(span=macd_slow, adjust=False).mean()
        df['macd_signal'] = df['macd'].ewm(span=macd_signal, adjust=False).mean()
        df['macd_hist'] = df['macd'] - df['macd_signal']
        
        # Calculate ADX
        # True Range
        df['high_low'] = df['high'] - df['low']
        df['high_close'] = np.abs(df['high'] - df['close'].shift())
        df['low_close'] = np.abs(df['low'] - df['close'].shift())
        df['tr'] = df[['high_low', 'high_close', 'low_close']].max(axis=1)
        df['atr'] = df['tr'].rolling(window=adx_period).mean()
        
        # Directional Movement
        df['up_move'] = df['high'] - df['high'].shift()
        df['down_move'] = df['low'].shift() - df['low']
        
        df['plus_dm'] = np.where((df['up_move'] > df['down_move']) & (df['up_move'] > 0), df['up_move'], 0)
        df['minus_dm'] = np.where((df['down_move'] > df['up_move']) & (df['down_move'] > 0), df['down_move'], 0)
        
        # Directional Indicators
        df['plus_di'] = 100 * (df['plus_dm'].rolling(window=adx_period).mean() / df['atr'])
        df['minus_di'] = 100 * (df['minus_dm'].rolling(window=adx_period).mean() / df['atr'])
        
        # Directional Index
        df['dx'] = 100 * np.abs(df['plus_di'] - df['minus_di']) / (df['plus_di'] + df['minus_di'])
        df['adx'] = df['dx'].rolling(window=adx_period).mean()
        
        # Fill NaN values
        df.dropna(inplace=True)
        
        if len(df) < 5:
            return signals
        
        # Get the latest data
        latest = df.iloc[-1]
        prev = df.iloc[-2]
        prev2 = df.iloc[-3]
        
        # Check for trend following conditions
        
        # Bullish signal: Fast EMA crosses above Slow EMA with ADX > threshold and MACD confirmation
        if (prev.fast_ema <= prev.slow_ema and latest.fast_ema > latest.slow_ema and
            latest.adx > adx_threshold and
            latest.macd > latest.macd_signal and latest.macd_hist > prev.macd_hist):
            
            # Calculate signal strength based on ADX and MACD
            adx_strength = min((latest.adx - adx_threshold) / 10, 2.0)
            macd_strength = min(latest.macd_hist / 0.5, 2.0)
            
            # Determine overall signal strength
            if adx_strength > 1.0 and macd_strength > 1.0:
                strength = SignalStrength.STRONG_BUY
            elif adx_strength > 0.5 or macd_strength > 0.5:
                strength = SignalStrength.MODERATE_BUY
            else:
                strength = SignalStrength.WEAK_BUY
            
            # Calculate stop loss and take profit
            stop_loss = self.calculate_stop_loss(latest.close, TradeDirection.LONG, candles)
            take_profit = self.calculate_take_profit(TradeDirection.LONG, latest.close, stop_loss, candles, stock_config)
            
            # Create signal
            signal = Signal(
                timestamp=candles[-1].timestamp,
                symbol=symbol,
                strategy=self.name,
                direction=TradeDirection.LONG,
                strength=strength,
                entry_price=latest.close,
                stop_loss=stop_loss,
                take_profit=take_profit,
                expiration=candles[-1].timestamp + dt.timedelta(days=2),
                metadata={
                    "adx": latest.adx,
                    "plus_di": latest.plus_di,
                    "minus_di": latest.minus_di,
                    "fast_ema": latest.fast_ema,
                    "slow_ema": latest.slow_ema,
                    "macd": latest.macd,
                    "macd_signal": latest.macd_signal,
                    "macd_hist": latest.macd_hist
                }
            )
            
            signals.append(signal)
        
        # Bearish signal: Fast EMA crosses below Slow EMA with ADX > threshold and MACD confirmation
        elif (prev.fast_ema >= prev.slow_ema and latest.fast_ema < latest.slow_ema and
              latest.adx > adx_threshold and
              latest.macd < latest.macd_signal and latest.macd_hist < prev.macd_hist):
            
            # Calculate signal strength based on ADX and MACD
            adx_strength = min((latest.adx - adx_threshold) / 10, 2.0)
            macd_strength = min(abs(latest.macd_hist) / 0.5, 2.0)
            
            # Determine overall signal strength
            if adx_strength > 1.0 and macd_strength > 1.0:
                strength = SignalStrength.STRONG_SELL
            elif adx_strength > 0.5 or macd_strength > 0.5:
                strength = SignalStrength.MODERATE_SELL
            else:
                strength = SignalStrength.WEAK_SELL
            
            # Calculate stop loss and take profit
            stop_loss = self.calculate_stop_loss(latest.close, TradeDirection.SHORT, candles)
            take_profit = self.calculate_take_profit(TradeDirection.SHORT, latest.close, stop_loss, candles, stock_config)
            
            # Create signal
            signal = Signal(
                timestamp=candles[-1].timestamp,
                symbol=symbol,
                strategy=self.name,
                direction=TradeDirection.SHORT,
                strength=strength,
                entry_price=latest.close,
                stop_loss=stop_loss,
                take_profit=take_profit,
                expiration=candles[-1].timestamp + dt.timedelta(days=5),  # Extend expiration to 5 days
                metadata={
                    "adx": latest.adx,
                    "plus_di": latest.plus_di,
                    "minus_di": latest.minus_di,
                    "fast_ema": latest.fast_ema,
                    "slow_ema": latest.slow_ema,
                    "macd": latest.macd,
                    "macd_signal": latest.macd_signal,
                    "macd_hist": latest.macd_hist
                }
            )
            
            signals.append(signal)
        
        return signals
    
    def calculate_stop_loss(self, 
                           current_price: float, 
                           direction: TradeDirection, 
                           candles: List[CandleData]) -> float:
        """Calculate stop loss price for a trade."""
        if len(candles) < 5:
            # Not enough data, use a default 2% stop loss
            return current_price * 0.98 if direction == TradeDirection.LONG else current_price * 1.02
        
        # Use recent price action to determine stop loss
        recent_candles = candles[-5:]
        
        if direction == TradeDirection.LONG:
            # For long positions, set stop loss below recent lows
            lowest_low = min(candle.low for candle in recent_candles)
            stop_loss = lowest_low * 0.99  # Add a small buffer
            
            # Ensure stop loss is not too far from entry price (max 3%)
            max_stop_distance = current_price * 0.03
            if current_price - stop_loss > max_stop_distance:
                stop_loss = current_price - max_stop_distance
            
            return stop_loss
        else:
            # For short positions, set stop loss above recent highs
            highest_high = max(candle.high for candle in recent_candles)
            stop_loss = highest_high * 1.01  # Add a small buffer
            
            # Ensure stop loss is not too far from entry price (max 3%)
            max_stop_distance = current_price * 0.03
            if stop_loss - current_price > max_stop_distance:
                stop_loss = current_price + max_stop_distance
            
            return stop_loss
    
    def calculate_take_profit(self, 
                             direction: TradeDirection,
                             entry_price: float,
                             stop_loss: float,
                             candles: List[CandleData],
                             stock_config: StockConfig) -> float:
        """Calculate take profit price based on risk-reward ratio and support/resistance levels"""
        # Calculate risk
        risk = abs(entry_price - stop_loss)
        
        # Set default risk-reward ratio
        risk_reward = 2.0
        
        # Check if we can identify a clear target based on support/resistance
        if len(candles) >= 50:
            df = pd.DataFrame([candle.to_dict() for candle in candles[-50:]])
            
            if direction == TradeDirection.LONG:
                # Look for resistance levels above current price
                resistance_levels = []
                
                # Identify significant highs
                for i in range(2, len(df) - 2):
                    if (df.iloc[i].high > df.iloc[i-1].high and 
                        df.iloc[i].high > df.iloc[i-2].high and
                        df.iloc[i].high > df.iloc[i+1].high and
                        df.iloc[i].high > df.iloc[i+2].high):
                        resistance_levels.append(df.iloc[i].high)
                
                # Find the nearest resistance level above entry
                valid_levels = [level for level in resistance_levels if level > entry_price]
                if valid_levels:
                    nearest_resistance = min(valid_levels)
                    potential_reward = nearest_resistance - entry_price
                    
                    # If the nearest resistance offers at least 1.5x risk, use it
                    if potential_reward >= risk * 1.5:
                        return nearest_resistance
            
            else:  # SHORT
                # Look for support levels below current price
                support_levels = []
                
                # Identify significant lows
                for i in range(2, len(df) - 2):
                    if (df.iloc[i].low < df.iloc[i-1].low and 
                        df.iloc[i].low < df.iloc[i-2].low and
                        df.iloc[i].low < df.iloc[i+1].low and
                        df.iloc[i].low < df.iloc[i+2].low):
                        support_levels.append(df.iloc[i].low)
                
                # Find the nearest support level below entry
                valid_levels = [level for level in support_levels if level < entry_price]
                if valid_levels:
                    nearest_support = max(valid_levels)
                    potential_reward = entry_price - nearest_support
                    
                    # If the nearest support offers at least 1.5x risk, use it
                    if potential_reward >= risk * 1.5:
                        return nearest_support
        
        # If we couldn't find a good support/resistance level, use risk-reward ratio
        if direction == TradeDirection.LONG:
            return entry_price + (risk * risk_reward)
        else:
            return entry_price - (risk * risk_reward)
    
    def should_exit_position(self, 
                            position: PositionState,
                            candles: List[CandleData],
                            market_state: MarketState) -> Tuple[bool, str]:
        """Check if a position should be exited"""
        if len(candles) < self.get_param("slow_ema_period", 21) + 5:
            return False, ""
        
        current_price = candles[-1].close
        
        # Check stop loss
        if position.direction == TradeDirection.LONG and current_price <= position.stop_loss:
            return True, "Stop loss triggered"
        if position.direction == TradeDirection.SHORT and current_price >= position.stop_loss:
            return True, "Stop loss triggered"
        
        # Check take profit
        if position.take_profit is not None:
            if position.direction == TradeDirection.LONG and current_price >= position.take_profit:
                return True, "Take profit reached"
            if position.direction == TradeDirection.SHORT and current_price <= position.take_profit:
                return True, "Take profit reached"
        
        # Convert candles to DataFrame for calculations
        df = pd.DataFrame([candle.to_dict() for candle in candles])
        df.set_index('timestamp', inplace=True)
        
        # Calculate EMAs
        df['fast_ema'] = df['close'].ewm(span=self.get_param("fast_ema_period", 9), adjust=False).mean()
        df['slow_ema'] = df['close'].ewm(span=self.get_param("slow_ema_period", 21), adjust=False).mean()
        
        # Calculate MACD
        df['macd'] = df['close'].ewm(span=self.get_param("macd_fast", 12), adjust=False).mean() - df['close'].ewm(span=self.get_param("macd_slow", 26), adjust=False).mean()
        df['macd_signal'] = df['macd'].ewm(span=self.get_param("macd_signal", 9), adjust=False).mean()
        df['macd_hist'] = df['macd'] - df['macd_signal']
        
        # Check for trend reversal signals
        latest = df.iloc[-1]
        prev = df.iloc[-2]
        
        # For long positions, exit on bearish reversal signals
        if position.direction == TradeDirection.LONG:
            # EMA cross down
            if prev.fast_ema >= prev.slow_ema and latest.fast_ema < latest.slow_ema:
                return True, "EMA crossover (bearish)"
            
            # MACD cross down
            if prev.macd >= prev.macd_signal and latest.macd < latest.macd_signal:
                return True, "MACD crossover (bearish)"
        
        # For short positions, exit on bullish reversal signals
        if position.direction == TradeDirection.SHORT:
            # EMA cross up
            if prev.fast_ema <= prev.slow_ema and latest.fast_ema > latest.slow_ema:
                return True, "EMA crossover (bullish)"
            
            # MACD cross up
            if prev.macd <= prev.macd_signal and latest.macd > latest.macd_signal:
                return True, "MACD crossover (bullish)"
        
        return False, ""
    
    def calculate_regime_weight(self, market_state: MarketState) -> float:
        """Calculate weight based on market regime"""
        # Trend following works best in trending markets
        if market_state.regime in [MarketRegime.TRENDING_BULLISH, MarketRegime.TRENDING_BEARISH]:
            return 2.0
        elif market_state.regime == MarketRegime.HIGH_VOLATILITY:
            return 1.2
        elif market_state.regime == MarketRegime.RANGE_BOUND:
            return 0.5
        elif market_state.regime == MarketRegime.LOW_VOLATILITY:
            return 0.8
        else:
            return 1.0

class VolatilityBreakoutStrategy(Strategy):
    """Volatility breakout strategy using Bollinger Band squeeze"""
    
    def __init__(self, config: Dict):
        super().__init__("VolatilityBreakout", config)
        # Strategy parameters are now accessed via get_param method
    
    def generate_signals(self, 
                        symbol: str, 
                        candles: List[CandleData],
                        stock_config: StockConfig,
                        market_state: MarketState) -> List[Signal]:
        """Generate volatility breakout signals based on Bollinger Band squeeze"""
        signals = []
        
        try:
            # Get parameters from config - updated parameter names to match configuration file
            bb_period = self.get_param("bb_period", 20)  # Changed from hardcoded bb_period
            bb_std_dev = self.get_param("bb_std_dev", 2.0)  # Added from config
            keltner_period = self.get_param("keltner_period", 20)  # Keep this as is
            keltner_factor = self.get_param("keltner_factor", 1.5)  # Keep this as is
            min_squeeze_periods = self.get_param("min_squeeze_periods", 10)  # Keep this as is
            volume_threshold = self.get_param("volume_threshold", 1.5)  # Volume surge threshold
            
            # Log the parameters being used
            self.logger.info(f"VolatilityBreakout generating signals for {symbol} with {len(candles)} candles")
            self.logger.info(f"Parameters: bb_period={bb_period}, bb_std_dev={bb_std_dev}, "
                        f"keltner_period={keltner_period}, keltner_factor={keltner_factor}, "
                        f"min_squeeze_periods={min_squeeze_periods}, volume_threshold={volume_threshold}")
            
            if len(candles) < bb_period + min_squeeze_periods + 5:
                # Not enough data for calculation
                self.logger.warning(f"Not enough candles for {symbol}: {len(candles)} < {bb_period + min_squeeze_periods + 5}")
                return signals
            
            # Convert candles to DataFrame for easier calculation
            df = pd.DataFrame([candle.to_dict() for candle in candles])
            df.set_index('timestamp', inplace=True)
            
            # Calculate Bollinger Bands
            df['sma'] = df['close'].rolling(window=bb_period).mean()
            df['std'] = df['close'].rolling(window=bb_period).std()
            df['bb_upper'] = df['sma'] + (df['std'] * bb_std_dev)
            df['bb_lower'] = df['sma'] - (df['std'] * bb_std_dev)
            df['bb_width'] = (df['bb_upper'] - df['bb_lower']) / df['sma']
            
            # Calculate Keltner Channels
            df['ema'] = df['close'].ewm(span=keltner_period, adjust=False).mean()
            df['atr'] = self._calculate_atr(df, keltner_period)
            
            # Check if atr calculation returned valid values
            if df['atr'].isna().all():
                self.logger.warning(f"ATR calculation failed for {symbol}")
                return signals
            
            df['kc_upper'] = df['ema'] + (df['atr'] * keltner_factor)
            df['kc_lower'] = df['ema'] - (df['atr'] * keltner_factor)
            
            # Identify squeeze (Bollinger Bands inside Keltner Channels)
            df['squeeze'] = (df['bb_lower'] > df['kc_lower']) & (df['bb_upper'] < df['kc_upper'])
            
            # Log squeeze information
            squeeze_count = df['squeeze'].sum()
            self.logger.info(f"{symbol} has {squeeze_count} squeeze periods out of {len(df)} total periods")
            
            # Identify when a squeeze is ending (transitioning from squeeze to non-squeeze)
            df['squeeze_ending'] = df['squeeze'].shift(1) & ~df['squeeze']
            
            # Calculate momentum (rate of change)
            df['momentum'] = df['close'].pct_change(5) * 100
            
            # Calculate volume surge
            df['volume_sma'] = df['volume'].rolling(window=20).mean()
            df['volume_ratio'] = df['volume'] / df['volume_sma']
            
            # Fill NaN values
            df.dropna(inplace=True)
            
            if len(df) < 5:
                self.logger.warning(f"Not enough data after dropna for {symbol}: {len(df)}")
                return signals
            
            # Look for squeeze setups followed by breakouts
            for i in range(len(df) - 1, max(0, len(df) - 10), -1):  # Check last 10 candles instead of 5
                # Check if we have a squeeze ending
                if df.iloc[i]['squeeze_ending']:
                    self.logger.info(f"Found squeeze ending for {symbol} at {df.index[i]}")
                    
                    # Check if we had a sustained squeeze before this
                    squeeze_duration = 0
                    for j in range(i-1, max(0, i-min_squeeze_periods-5), -1):  # Add buffer of 5
                        if df.iloc[j]['squeeze']:
                            squeeze_duration += 1
                        else:
                            break
                    
                    self.logger.info(f"Squeeze duration for {symbol}: {squeeze_duration} periods (min required: {min_squeeze_periods})")
                    
                    # Only proceed if we had a sufficiently long squeeze
                    if squeeze_duration >= min_squeeze_periods:
                        # Check for a breakout with volume confirmation
                        current = df.iloc[i]
                        prev = df.iloc[i-1]
                        
                        # Log current conditions
                        self.logger.info(f"{symbol} breakout check - Close: {current.close:.2f}, SMA: {current.sma:.2f}, "
                                    f"Volume ratio: {current.volume_ratio:.2f}, Momentum: {current.momentum:.2f}")
                        
                        # Bullish breakout
                        if (current.close > current.sma and 
                            current.close > prev.close and
                            current.volume_ratio > volume_threshold and
                            current.momentum > 0):
                            
                            self.logger.info(f"Bullish breakout detected for {symbol}")
                            
                            # Calculate signal strength based on momentum and volume
                            momentum_strength = min(current.momentum / 2, 2.0)
                            volume_strength = min((current.volume_ratio - 1) / 0.5, 2.0)
                            
                            # Determine overall signal strength
                            if momentum_strength > 1.0 and volume_strength > 1.0:
                                strength = SignalStrength.STRONG_BUY
                            elif momentum_strength > 0.5 or volume_strength > 0.5:
                                strength = SignalStrength.MODERATE_BUY
                            else:
                                strength = SignalStrength.WEAK_BUY
                            
                            # Calculate stop loss and take profit
                            entry_price = current.close
                            stop_loss = self.calculate_stop_loss(entry_price, TradeDirection.LONG, candles[-i-1:])
                            take_profit = self.calculate_take_profit(TradeDirection.LONG, entry_price, stop_loss, candles[-i-1:], stock_config)
                            
                            # Create signal
                            signal = Signal(
                                timestamp=df.index[i],
                                symbol=symbol,
                                strategy=self.name,
                                direction=TradeDirection.LONG,
                                strength=strength,
                                entry_price=entry_price,
                                stop_loss=stop_loss,
                                take_profit=take_profit,
                                expiration=df.index[i] + dt.timedelta(days=3),
                                metadata={
                                    "squeeze_duration": squeeze_duration,
                                    "momentum": current.momentum,
                                    "volume_ratio": current.volume_ratio,
                                    "bb_width": current.bb_width
                                }
                            )
                            
                            signals.append(signal)
                            self.logger.info(f"Added bullish signal for {symbol} with strength {strength}")
                        
                        # Bearish breakout
                        elif (current.close < current.sma and
                              current.close < prev.close and
                              current.volume_ratio > volume_threshold and
                              current.momentum < 0):
                            
                            self.logger.info(f"Bearish breakout detected for {symbol}")
                            
                            # Calculate signal strength based on momentum and volume
                            momentum_strength = min(abs(current.momentum) / 2, 2.0)
                            volume_strength = min((current.volume_ratio - 1) / 0.5, 2.0)
                            
                            # Determine overall signal strength
                            if momentum_strength > 1.0 and volume_strength > 1.0:
                                strength = SignalStrength.STRONG_SELL
                            elif momentum_strength > 0.5 or volume_strength > 0.5:
                                strength = SignalStrength.MODERATE_SELL
                            else:
                                strength = SignalStrength.WEAK_SELL
                            
                            # Calculate stop loss and take profit
                            entry_price = current.close
                            stop_loss = self.calculate_stop_loss(entry_price, TradeDirection.SHORT, candles[-i-1:])
                            take_profit = self.calculate_take_profit(TradeDirection.SHORT, entry_price, stop_loss, candles[-i-1:], stock_config)
                            
                            # Create signal
                            signal = Signal(
                                timestamp=df.index[i],
                                symbol=symbol,
                                strategy=self.name,
                                direction=TradeDirection.SHORT,
                                strength=strength,
                                entry_price=entry_price,
                                stop_loss=stop_loss,
                                take_profit=take_profit,
                                expiration=df.index[i] + dt.timedelta(days=5),  # Extend expiration to 5 days
                                metadata={
                                    "squeeze_duration": squeeze_duration,
                                    "momentum": current.momentum,
                                    "volume_ratio": current.volume_ratio,
                                    "bb_width": current.bb_width
                                }
                            )
                            
                            signals.append(signal)
                            self.logger.info(f"Added bearish signal for {symbol} with strength {strength}")
        except Exception as e:
            # Log the error but don't crash
            self.logger.error(f"Error in VolatilityBreakout strategy for {symbol}: {str(e)}")
            # Return empty signals list
            return []
                
        return signals
    
    def _calculate_atr(self, df: pd.DataFrame, period: int) -> pd.Series:
        """Calculate Average True Range"""
        high = df['high']
        low = df['low']
        close = df['close'].shift(1)
        
        tr1 = high - low
        tr2 = (high - close).abs()
        tr3 = (low - close).abs()
        
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        atr = tr.rolling(window=period).mean()
        
        return atr
    
    def calculate_stop_loss(self, 
                           current_price: float, 
                           direction: TradeDirection, 
                           candles: List[CandleData]) -> float:
        """Calculate stop loss price for a trade."""
        if len(candles) < 5:
            # Not enough data, use a default 2% stop loss
            return current_price * 0.98 if direction == TradeDirection.LONG else current_price * 1.02
        
        # Use recent price action to determine stop loss
        recent_candles = candles[-5:]
        
        if direction == TradeDirection.LONG:
            # For long positions, set stop loss below recent lows
            lowest_low = min(candle.low for candle in recent_candles)
            stop_loss = lowest_low * 0.99  # Add a small buffer
            
            # Ensure stop loss is not too far from entry price (max 3%)
            max_stop_distance = current_price * 0.03
            if current_price - stop_loss > max_stop_distance:
                stop_loss = current_price - max_stop_distance
            
            return stop_loss
        else:
            # For short positions, set stop loss above recent highs
            highest_high = max(candle.high for candle in recent_candles)
            stop_loss = highest_high * 1.01  # Add a small buffer
            
            # Ensure stop loss is not too far from entry price (max 3%)
            max_stop_distance = current_price * 0.03
            if stop_loss - current_price > max_stop_distance:
                stop_loss = current_price + max_stop_distance
            
            return stop_loss
    
    def calculate_take_profit(self, 
                             direction: TradeDirection,
                             entry_price: float,
                             stop_loss: float,
                             candles: List[CandleData],
                             stock_config: StockConfig) -> float:
        """Calculate take profit price based on ATR and recent volatility"""
        # Convert candles to DataFrame
        df = pd.DataFrame([candle.to_dict() for candle in candles])
        df.set_index('timestamp', inplace=True)
        
        # Calculate ATR
        atr = self._calculate_atr(df, 14).iloc[-1]
        
        # More aggressive target during volatility breakouts
        if direction == TradeDirection.LONG:
            return entry_price + (atr * 2.5)
        else:
            return entry_price - (atr * 2.5)
    
    def should_exit_position(self, 
                            position: PositionState,
                            candles: List[CandleData],
                            market_state: MarketState) -> Tuple[bool, str]:
        """Check if a position should be exited"""
        if len(candles) < 5:
            return False, ""
        
        current_price = candles[-1].close
        
        # Check stop loss
        if position.direction == TradeDirection.LONG and current_price <= position.stop_loss:
            return True, "Stop loss triggered"
        if position.direction == TradeDirection.SHORT and current_price >= position.stop_loss:
            return True, "Stop loss triggered"
        
        # Check take profit
        if position.take_profit is not None:
            if position.direction == TradeDirection.LONG and current_price >= position.take_profit:
                return True, "Take profit reached"
            if position.direction == TradeDirection.SHORT and current_price <= position.take_profit:
                return True, "Take profit reached"
        
        # Convert candles to DataFrame
        df = pd.DataFrame([candle.to_dict() for candle in candles[-20:]])
        df.set_index('timestamp', inplace=True)
        
        # Calculate momentum (rate of change)
        df['momentum'] = df['close'].pct_change(5) * 100
        
        # Check for momentum reversal
        if position.direction == TradeDirection.LONG:
            # Exit if momentum turns significantly negative
            if df['momentum'].iloc[-1] < -1.0 and df['momentum'].iloc[-2] < df['momentum'].iloc[-3]:
                return True, "Momentum reversal"
        else:
            # Exit if momentum turns significantly positive
            if df['momentum'].iloc[-1] > 1.0 and df['momentum'].iloc[-2] > df['momentum'].iloc[-3]:
                return True, "Momentum reversal"
        
        # Check for potential exhaustion (price moving too fast)
        daily_range = (candles[-1].high - candles[-1].low) / candles[-1].low * 100
        if daily_range > 5:  # More than 5% range in a day
            if position.direction == TradeDirection.LONG and current_price < candles[-1].high * 0.98:
                return True, "Exhaustion/reversal"
            if position.direction == TradeDirection.SHORT and current_price > candles[-1].low * 1.02:
                return True, "Exhaustion/reversal"
        
        return False, ""
    
    def calculate_regime_weight(self, market_state: MarketState) -> float:
        """Calculate weight based on market regime"""
        # Volatility breakout works best when volatility is expanding
        if market_state.regime == MarketRegime.HIGH_VOLATILITY:
            return 2.0
        elif market_state.regime in [MarketRegime.TRENDING_BULLISH, MarketRegime.TRENDING_BEARISH]:
            return 1.3
        elif market_state.regime == MarketRegime.RANGE_BOUND:
            return 0.8
        elif market_state.regime == MarketRegime.LOW_VOLATILITY:
            return 1.5  # Good for catching the transition from low to high volatility
        else:
            return 1.0

class GapTradingStrategy(Strategy):
    """Gap and Go strategy that trades significant gaps at market open"""
    
    def __init__(self, config: Dict):
        super().__init__("GapTrading", config)
        # Strategy parameters are now accessed via get_param method
    
    def generate_signals(self, 
                        symbol: str, 
                        candles: List[CandleData],
                        stock_config: StockConfig,
                        market_state: MarketState) -> List[Signal]:
        """Generate gap trading signals"""
        signals = []
        
        # Get parameters from config
        min_gap_pct = self.get_param("min_gap_pct", 2.0)  # Minimum gap size in percent
        min_volume_pct = self.get_param("min_volume_pct", 150)  # Minimum pre-market volume in percent of average
        consolidation_periods = self.get_param("consolidation_periods", 3)  # Number of periods to wait for consolidation
        trade_direction = self.get_param("trade_direction", "both")  # "up", "down", or "both"
        
        # Need at least one day of data plus today's first few candles
        if len(candles) < 390 + consolidation_periods:  # 390 minutes in a trading day
            return signals
        
        # Convert candles to DataFrame for easier calculation
        df = pd.DataFrame([candle.to_dict() for candle in candles])
        df.set_index('timestamp', inplace=True)
        
        # Identify the current day
        current_day = df.index[-1].date()
        
        # Get previous day's close
        prev_day_data = df[df.index.date < current_day]
        if len(prev_day_data) == 0:
            return signals
        
        prev_close = prev_day_data.iloc[-1]['close']
        
        # Get today's open
        today_data = df[df.index.date == current_day]
        if len(today_data) < consolidation_periods + 1:
            return signals
        
        today_open = today_data.iloc[0]['open']
        
        # Calculate gap percentage
        gap_pct = (today_open - prev_close) / prev_close * 100
        
        # Only consider significant gaps
        if abs(gap_pct) < min_gap_pct:
            return signals
        
        # Calculate today's volume compared to average
        avg_volume = prev_day_data.iloc[-20:]['volume'].mean() if len(prev_day_data) >= 20 else prev_day_data['volume'].mean()
        today_volume = today_data.iloc[0:consolidation_periods]['volume'].sum()
        volume_pct = (today_volume / avg_volume) * 100
        
        # Ensure sufficient volume
        if volume_pct < min_volume_pct:
            return signals
        
        # Check for gap direction
        gap_direction = "up" if gap_pct > 0 else "down"
        
        # Only proceed if we're trading this gap direction
        if trade_direction != "both" and gap_direction != trade_direction:
            return signals
        
        # Check for consolidation pattern after the gap
        consolidation_candles = today_data.iloc[:consolidation_periods]
        
        # For gap up, look for a tight consolidation near the highs
        if gap_direction == "up":
            high = consolidation_candles['high'].max()
            low = consolidation_candles['low'].min()
            latest = today_data.iloc[consolidation_periods]
            
            # Calculate consolidation tightness
            range_pct = (high - low) / low * 100
            
            # Only trade tight consolidations (less than half the gap size)
            if range_pct > abs(gap_pct) / 2:
                return signals
            
            # Generate long signal if price breaks above consolidation
            if latest['close'] > high and latest['close'] > latest['open']:
                # Calculate signal strength based on gap size and volume
                gap_strength = min(gap_pct / 2, 2.0)
                volume_strength = min((volume_pct - 100) / 50, 2.0)
                
                # Determine overall signal strength
                if gap_strength > 1.0 and volume_strength > 1.0:
                    strength = SignalStrength.STRONG_BUY
                elif gap_strength > 0.5 or volume_strength > 0.5:
                    strength = SignalStrength.MODERATE_BUY
                else:
                    strength = SignalStrength.WEAK_BUY
                
                # Calculate stop loss and take profit
                entry_price = latest['close']
                stop_loss = low  # Place stop below the consolidation
                take_profit = self.calculate_take_profit(TradeDirection.LONG, entry_price, stop_loss, candles, stock_config)
                
                # Create signal
                signal = Signal(
                    timestamp=latest.name,
                    symbol=symbol,
                    strategy=self.name,
                    direction=TradeDirection.LONG,
                    strength=strength,
                    entry_price=entry_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    expiration=latest.name + dt.timedelta(hours=4),  # Expire in 4 hours
                    metadata={
                        "gap_pct": gap_pct,
                        "volume_pct": volume_pct,
                        "consolidation_range_pct": range_pct
                    }
                )
                
                signals.append(signal)
        
        # For gap down, look for a tight consolidation near the lows
        elif gap_direction == "down":
            high = consolidation_candles['high'].max()
            low = consolidation_candles['low'].min()
            latest = today_data.iloc[consolidation_periods]
            
            # Calculate consolidation tightness
            range_pct = (high - low) / low * 100
            
            # Only trade tight consolidations (less than half the gap size)
            if range_pct > abs(gap_pct) / 2:
                return signals
            
            # Generate short signal if price breaks below consolidation
            if latest['close'] < low and latest['close'] < latest['open']:
                # Calculate signal strength based on gap size and volume
                gap_strength = min(abs(gap_pct) / 2, 2.0)
                volume_strength = min((volume_pct - 100) / 50, 2.0)
                
                # Determine overall signal strength
                if gap_strength > 1.0 and volume_strength > 1.0:
                    strength = SignalStrength.STRONG_SELL
                elif gap_strength > 0.5 or volume_strength > 0.5:
                    strength = SignalStrength.MODERATE_SELL
                else:
                    strength = SignalStrength.WEAK_SELL
                
                # Calculate stop loss and take profit
                entry_price = latest['close']
                stop_loss = high  # Place stop above the consolidation
                take_profit = self.calculate_take_profit(TradeDirection.SHORT, entry_price, stop_loss, candles, stock_config)
                
                # Create signal
                signal = Signal(
                    timestamp=latest.name,
                    symbol=symbol,
                    strategy=self.name,
                    direction=TradeDirection.SHORT,
                    strength=strength,
                    entry_price=entry_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    expiration=latest.name + dt.timedelta(hours=4),  # Expire in 4 hours
                    metadata={
                        "gap_pct": gap_pct,
                        "volume_pct": volume_pct,
                        "consolidation_range_pct": range_pct
                    }
                )
                
                signals.append(signal)
    
    def calculate_stop_loss(self, 
                           current_price: float, 
                           direction: TradeDirection, 
                           candles: List[CandleData]) -> float:
        """Calculate stop loss price for a trade."""
        if len(candles) < 5:
            # Not enough data, use a default 2% stop loss
            return current_price * 0.98 if direction == TradeDirection.LONG else current_price * 1.02
        
        # Use recent price action to determine stop loss
        recent_candles = candles[-5:]
        
        if direction == TradeDirection.LONG:
            # For long positions, set stop loss below recent lows
            lowest_low = min(candle.low for candle in recent_candles)
            stop_loss = lowest_low * 0.99  # Add a small buffer
            
            # Ensure stop loss is not too far from entry price (max 3%)
            max_stop_distance = current_price * 0.03
            if current_price - stop_loss > max_stop_distance:
                stop_loss = current_price - max_stop_distance
            
            return stop_loss
        else:
            # For short positions, set stop loss above recent highs
            highest_high = max(candle.high for candle in recent_candles)
            stop_loss = highest_high * 1.01  # Add a small buffer
            
            # Ensure stop loss is not too far from entry price (max 3%)
            max_stop_distance = current_price * 0.03
            if stop_loss - current_price > max_stop_distance:
                stop_loss = current_price + max_stop_distance
            
            return stop_loss
    
    def calculate_take_profit(self, 
                             direction: TradeDirection,
                             entry_price: float,
                             stop_loss: float,
                             candles: List[CandleData],
                             stock_config: StockConfig) -> float:
        """Calculate take profit price based on gap fill and risk-reward ratio"""
        # Convert candles to DataFrame
        df = pd.DataFrame([candle.to_dict() for candle in candles])
        df.set_index('timestamp', inplace=True)
        
        # Identify the current day
        current_day = df.index[-1].date()
        
        # Get previous day's data
        prev_day_data = df[df.index.date < current_day]
        
        if len(prev_day_data) == 0:
            # If no previous day's data, use a standard risk-reward ratio
            risk = abs(entry_price - stop_loss)
            if direction == TradeDirection.LONG:
                return entry_price + (risk * 2)
            else:
                return entry_price - (risk * 2)
        
        prev_close = prev_day_data.iloc[-1]['close']
        prev_high = prev_day_data['high'].max()
        prev_low = prev_day_data['low'].min()
        
        # For gap trades, the target is often the gap fill
        if direction == TradeDirection.LONG:
            # For gap up, target the previous day's high or a 2:1 risk/reward
            risk = entry_price - stop_loss
            min_target = entry_price + (risk * 2)
            gap_fill_target = prev_high
            
            # Use the closer target
            return min(min_target, gap_fill_target) if gap_fill_target > entry_price else min_target
        else:
            # For gap down, target the previous day's low or a 2:1 risk/reward
            risk = stop_loss - entry_price
            min_target = entry_price - (risk * 2)
            gap_fill_target = prev_low
            
            # Use the closer target
            return max(min_target, gap_fill_target) if gap_fill_target < entry_price else min_target
    
    def should_exit_position(self, 
                            position: PositionState,
                            candles: List[CandleData],
                            market_state: MarketState) -> Tuple[bool, str]:
        """Check if a position should be exited"""
        if len(candles) < 2:
            return False, ""
        
        current_price = candles[-1].close
        
        # Check stop loss
        if position.direction == TradeDirection.LONG and current_price <= position.stop_loss:
            return True, "Stop loss triggered"
        if position.direction == TradeDirection.SHORT and current_price >= position.stop_loss:
            return True, "Stop loss triggered"
        
        # Check take profit
        if position.take_profit is not None:
            if position.direction == TradeDirection.LONG and current_price >= position.take_profit:
                return True, "Take profit reached"
            if position.direction == TradeDirection.SHORT and current_price <= position.take_profit:
                return True, "Take profit reached"
        
        # Convert candles to DataFrame
        df = pd.DataFrame([candle.to_dict() for candle in candles[-20:]])
        df.set_index('timestamp', inplace=True)
        
        # Calculate momentum (rate of change)
        df['momentum'] = df['close'].pct_change(5) * 100
        
        # Check for momentum loss
        if position.direction == TradeDirection.LONG:
            # Exit if momentum turns significantly negative
            if df['momentum'].iloc[-1] < -1.0 and df['momentum'].iloc[-2] < df['momentum'].iloc[-3]:
                return True, "Momentum loss"
        else:
            # Exit if momentum turns significantly positive
            if df['momentum'].iloc[-1] > 1.0 and df['momentum'].iloc[-2] > df['momentum'].iloc[-3]:
                return True, "Momentum loss"
        
        # Check for potential exhaustion (price moving too fast)
        daily_range = (candles[-1].high - candles[-1].low) / candles[-1].low * 100
        if daily_range > 5:  # More than 5% range in a day
            if position.direction == TradeDirection.LONG and current_price < candles[-1].high * 0.98:
                return True, "Exhaustion/reversal"
            if position.direction == TradeDirection.SHORT and current_price > candles[-1].low * 1.02:
                return True, "Exhaustion/reversal"
        
        return False, ""
    
    def calculate_regime_weight(self, market_state: MarketState) -> float:
        """Calculate weight based on market regime"""
        # Gap trading works independently of market regime but
        # performs better in high volatility environments
        if market_state.regime == MarketRegime.HIGH_VOLATILITY:
            return 1.5
        elif market_state.regime in [MarketRegime.TRENDING_BULLISH, MarketRegime.TRENDING_BEARISH]:
            return 1.2
        else:
            return 1.0

# ===== Market Analysis =====

class MarketAnalyzer:
    """Analyzes market conditions to determine the current regime"""
    
    def __init__(self, config: Dict):
        """Initialize with configuration"""
        self.adx_period = config.get("adx_period", 14)
        self.vix_threshold_high = config.get("vix_threshold_high", 20)
        self.vix_threshold_low = config.get("vix_threshold_low", 15)
        self.adx_threshold_trending = config.get("adx_threshold_trending", 25)
        self.adx_threshold_range = config.get("adx_threshold_range", 20)
        self.lookback_period = config.get("lookback_period", 20)
        # New parameters for enhanced market regime detection
        self.regime_change_threshold = config.get("regime_change_threshold", 0.7)
        self.breadth_threshold = config.get("breadth_threshold", 0.6)
        self.sector_rotation_lookback = config.get("sector_rotation_lookback", 10)
        self.sentiment_threshold = config.get("sentiment_threshold", 0.65)
        self.logger = logging.getLogger("MarketAnalyzer")
        
        # Historical regime data for detecting transitions
        self.regime_history = []
        self.max_history = 20
    
    def analyze_market(self, market_data: List[CandleData], vix_data: List[CandleData],
                      sector_data: Dict[str, List[CandleData]] = None,
                      breadth_data: Dict[str, List[float]] = None,
                      intermarket_data: Dict[str, List[CandleData]] = None,
                      economic_data: Dict[str, float] = None,
                      sentiment_data: Dict[str, float] = None) -> MarketState:
        """Analyze market data to determine current regime with enhanced detection"""
        if len(market_data) < self.lookback_period or len(vix_data) < 5:
            # Not enough data, return unknown regime
            return MarketState(
                timestamp=dt.datetime.now(),
                regime=MarketRegime.UNKNOWN,
                vix=0.0,
                market_adx=0.0,
                trending_strength=0.0,
                range_bound_strength=0.0,
                volatility_strength=0.0,
                market_trend=TradeDirection.NEUTRAL,
                sector_performance={},
                breadth_indicators={},
                intermarket_indicators={},
                economic_indicators={},
                sentiment_indicators={},
                regime_change_probability=0.0,
                sub_regime=""
            )
        
        # Convert market data to DataFrame
        market_df = pd.DataFrame([candle.to_dict() for candle in market_data])
        market_df.set_index('timestamp', inplace=True)
        
        # Get current VIX value
        current_vix = vix_data[-1].close
        
        # Calculate ADX for trend strength
        adx, plus_di, minus_di = self._calculate_adx(market_df)
        
        # Determine trend direction
        if plus_di > minus_di:
            trend_direction = TradeDirection.LONG
        elif minus_di > plus_di:
            trend_direction = TradeDirection.SHORT
        else:
            trend_direction = TradeDirection.NEUTRAL
        
        # Calculate regime strengths
        trending_strength = min(adx / 40, 1.0)  # Normalize to 0-1
        range_bound_strength = max(0, 1.0 - trending_strength)
        volatility_strength = min(current_vix / 30, 1.0)  # Normalize to 0-1
        
        # Process sector data if available
        sector_performance = {}
        if sector_data:
            sector_performance = self._analyze_sector_performance(sector_data)
        
        # Process breadth data if available
        breadth_indicators = {}
        if breadth_data:
            breadth_indicators = self._analyze_breadth_indicators(breadth_data)
        
        # Process intermarket data if available
        intermarket_indicators = {}
        if intermarket_data:
            intermarket_indicators = self._analyze_intermarket_relationships(intermarket_data)
        
        # Process economic data if available
        economic_indicators = {}
        if economic_data:
            economic_indicators = economic_data
        
        # Process sentiment data if available
        sentiment_indicators = {}
        if sentiment_data:
            sentiment_indicators = sentiment_data
        
        # Enhanced regime determination
        regime, sub_regime = self._determine_regime(
            adx, plus_di, minus_di, current_vix, 
            trend_direction, market_df, 
            breadth_indicators, intermarket_indicators,
            sector_performance, sentiment_indicators
        )
        
        # Calculate regime change probability
        regime_change_probability = self._calculate_regime_change_probability(
            regime, trending_strength, volatility_strength, 
            breadth_indicators, intermarket_indicators
        )
        
        # Create market state
        market_state = MarketState(
            timestamp=market_data[-1].timestamp,
            regime=regime,
            vix=current_vix,
            market_adx=adx,
            trending_strength=trending_strength,
            range_bound_strength=range_bound_strength,
            volatility_strength=volatility_strength,
            market_trend=trend_direction,
            sector_performance=sector_performance,
            breadth_indicators=breadth_indicators,
            intermarket_indicators=intermarket_indicators,
            economic_indicators=economic_indicators,
            sentiment_indicators=sentiment_indicators,
            regime_change_probability=regime_change_probability,
            sub_regime=sub_regime
        )
        
        # Update regime history
        self.regime_history.append(market_state)
        if len(self.regime_history) > self.max_history:
            self.regime_history.pop(0)
        
        return market_state
    
    def _calculate_adx(self, df: pd.DataFrame) -> Tuple[float, float, float]:
        """Calculate Average Directional Index (ADX)"""
        # Calculate True Range
        df['high_low'] = df['high'] - df['low']
        df['high_close'] = np.abs(df['high'] - df['close'].shift())
        df['low_close'] = np.abs(df['low'] - df['close'].shift())
        df['tr'] = df[['high_low', 'high_close', 'low_close']].max(axis=1)
        df['atr'] = df['tr'].rolling(window=self.adx_period).mean()
        
        # Calculate Directional Movement
        df['up_move'] = df['high'] - df['high'].shift()
        df['down_move'] = df['low'].shift() - df['low']
        
        df['plus_dm'] = np.where((df['up_move'] > df['down_move']) & (df['up_move'] > 0), df['up_move'], 0)
        df['minus_dm'] = np.where((df['down_move'] > df['up_move']) & (df['down_move'] > 0), df['down_move'], 0)
        
        # Calculate Directional Indicators
        df['plus_di'] = 100 * (df['plus_dm'].rolling(window=self.adx_period).mean() / df['atr'])
        df['minus_di'] = 100 * (df['minus_dm'].rolling(window=self.adx_period).mean() / df['atr'])
        
        # Calculate Directional Index
        df['dx'] = 100 * np.abs(df['plus_di'] - df['minus_di']) / (df['plus_di'] + df['minus_di'])
        df['adx'] = df['dx'].rolling(window=self.adx_period).mean()
        
        # Get latest values
        latest_adx = df['adx'].iloc[-1]
        latest_plus_di = df['plus_di'].iloc[-1]
        latest_minus_di = df['minus_di'].iloc[-1]
        
        return latest_adx, latest_plus_di, latest_minus_di

    def _determine_regime(self, adx, plus_di, minus_di, vix, trend_direction, market_df, 
                         breadth_indicators, intermarket_indicators,
                         sector_performance, sentiment_indicators):
        """Enhanced regime determination using multiple factors"""
        # Base regime determination
        if adx > self.adx_threshold_trending:
            if trend_direction == TradeDirection.LONG:
                base_regime = MarketRegime.TRENDING_BULLISH
            else:
                base_regime = MarketRegime.TRENDING_BEARISH
        elif adx < self.adx_threshold_range:
            base_regime = MarketRegime.RANGE_BOUND
        elif vix > self.vix_threshold_high:
            base_regime = MarketRegime.HIGH_VOLATILITY
        elif vix < self.vix_threshold_low:
            base_regime = MarketRegime.LOW_VOLATILITY
        else:
            base_regime = MarketRegime.UNKNOWN
        
        # Check for breakouts/breakdowns
        if self._detect_breakout(market_df, breadth_indicators):
            if trend_direction == TradeDirection.LONG:
                base_regime = MarketRegime.BULLISH_BREAKOUT
            else:
                base_regime = MarketRegime.BEARISH_BREAKDOWN
        
        # Check for consolidation pattern
        if self._detect_consolidation(market_df):
            base_regime = MarketRegime.CONSOLIDATION
        
        # Determine sub-regime (more specific classification)
        sub_regime = self._determine_sub_regime(
            base_regime, adx, vix, trend_direction, 
            breadth_indicators, intermarket_indicators,
            sector_performance, sentiment_indicators
        )
        
        return base_regime, sub_regime
    
    def _determine_sub_regime(self, base_regime, adx, vix, trend_direction, 
                             breadth_indicators, intermarket_indicators,
                             sector_performance, sentiment_indicators):
        """Determine sub-regime based on additional indicators"""
        if base_regime == MarketRegime.TRENDING_BULLISH:
            if adx > 30 and vix < 15:
                return "Strong Uptrend"
            elif adx > 20 and vix < 20:
                return "Moderate Uptrend"
            else:
                return "Weak Uptrend"
        elif base_regime == MarketRegime.TRENDING_BEARISH:
            if adx > 30 and vix > 20:
                return "Strong Downtrend"
            elif adx > 20 and vix > 15:
                return "Moderate Downtrend"
            else:
                return "Weak Downtrend"
        elif base_regime == MarketRegime.RANGE_BOUND:
            if vix < 10:
                return "Low Volatility Range"
            elif vix < 20:
                return "Moderate Volatility Range"
            else:
                return "High Volatility Range"
        elif base_regime == MarketRegime.HIGH_VOLATILITY:
            if trend_direction == TradeDirection.LONG:
                return "Bullish Volatility Expansion"
            else:
                return "Bearish Volatility Expansion"
        elif base_regime == MarketRegime.LOW_VOLATILITY:
            if trend_direction == TradeDirection.LONG:
                return "Bullish Volatility Contraction"
            else:
                return "Bearish Volatility Contraction"
        elif base_regime == MarketRegime.BULLISH_BREAKOUT:
            if breadth_indicators and 'advance_decline_line' in breadth_indicators and breadth_indicators['advance_decline_line'] > 0:
                return "Broad Breakout"
            else:
                return "Narrow Breakout"
        elif base_regime == MarketRegime.BEARISH_BREAKDOWN:
            if breadth_indicators and 'advance_decline_line' in breadth_indicators and breadth_indicators['advance_decline_line'] < 0:
                return "Broad Breakdown"
            else:
                return "Narrow Breakdown"
        elif base_regime == MarketRegime.CONSOLIDATION:
            if sector_performance and 'technology' in sector_performance and 'healthcare' in sector_performance:
                if sector_performance['technology'] > 0 and sector_performance['healthcare'] > 0:
                    return "Bullish Consolidation"
                elif sector_performance['technology'] < 0 and sector_performance['healthcare'] < 0:
                    return "Bearish Consolidation"
                else:
                    return "Neutral Consolidation"
            else:
                return "Neutral Consolidation"  # Default if sector data is missing
        else:
            return ""

    def _detect_breakout(self, market_df, breadth_indicators):
        """Detect if the market is breaking out of a range"""
        try:
            # Calculate recent price range
            lookback = min(20, len(market_df) - 1)
            recent_high = market_df['high'].iloc[-lookback:-1].max()
            recent_low = market_df['low'].iloc[-lookback:-1].min()
            current_close = market_df['close'].iloc[-1]
            
            # Calculate average volume
            avg_volume = market_df['volume'].iloc[-lookback:-1].mean()
            current_volume = market_df['volume'].iloc[-1]
            
            # Check for price breakout with volume confirmation
            price_breakout = (current_close > recent_high * 1.01 or 
                             current_close < recent_low * 0.99)
            volume_confirmation = current_volume > avg_volume * 1.5
            
            # Check breadth confirmation if available
            breadth_confirmation = False
            if breadth_indicators and 'advance_decline_ratio' in breadth_indicators:
                breadth_confirmation = breadth_indicators['advance_decline_ratio'] > 1.5
            
            return price_breakout and (volume_confirmation or breadth_confirmation)
        except Exception as e:
            self.logger.error(f"Error in _detect_breakout: {str(e)}")
            return False

    def _detect_consolidation(self, market_df):
        """Detect if the market is in a consolidation pattern"""
        try:
            # Calculate recent price range
            lookback = min(20, len(market_df) - 1)
            recent_high = market_df['high'].iloc[-lookback:-1].max()
            recent_low = market_df['low'].iloc[-lookback:-1].min()
            current_close = market_df['close'].iloc[-1]
            
            # Check for consolidation pattern
            consolidation = (current_close > recent_low * 0.99 and 
                             current_close < recent_high * 1.01)
            
            return consolidation
        except Exception as e:
            self.logger.error(f"Error in _detect_consolidation: {str(e)}")
            return False

    def _analyze_sector_performance(self, sector_data):
        """Analyze relative performance of market sectors"""
        sector_performance = {}
        
        try:
            # Calculate relative performance for each sector
            for sector, candles in sector_data.items():
                if len(candles) < 5:
                    continue
                    
                # Calculate 5-day performance
                five_day_return = (candles[-1].close / candles[-5].close - 1) * 100
                sector_performance[sector] = five_day_return
        except Exception as e:
            self.logger.error(f"Error in _analyze_sector_performance: {str(e)}")
        
        return sector_performance
    
    def _analyze_breadth_indicators(self, breadth_data):
        """Analyze market breadth indicators"""
        breadth_indicators = {}
        
        try:
            # Process each breadth indicator
            for indicator, values in breadth_data.items():
                if not values:
                    continue
                    
                # Store the most recent value
                breadth_indicators[indicator] = values[-1]
                
                # Calculate rate of change if we have enough data
                if len(values) >= 5:
                    roc = (values[-1] / values[-5] - 1) * 100
                    breadth_indicators[f"{indicator}_roc"] = roc
        except Exception as e:
            self.logger.error(f"Error in _analyze_breadth_indicators: {str(e)}")
        
        return breadth_indicators

    def _analyze_intermarket_relationships(self, intermarket_data):
        """Analyze relationships between different markets"""
        intermarket_indicators = {}
        
        try:
            # Process intermarket relationships
            # Example: bonds vs stocks correlation
            if 'bonds' in intermarket_data and 'stocks' in intermarket_data:
                bond_data = intermarket_data['bonds']
                stock_data = intermarket_data['stocks']
                
                if len(bond_data) >= 10 and len(stock_data) >= 10:
                    # Calculate correlation
                    bond_prices = [candle.close for candle in bond_data[-10:]]
                    stock_prices = [candle.close for candle in stock_data[-10:]]
                    correlation = np.corrcoef(bond_prices, stock_prices)[0, 1]
                    intermarket_indicators['bond_stock_correlation'] = correlation
        except Exception as e:
            self.logger.error(f"Error in _analyze_intermarket_relationships: {str(e)}")
        
        return intermarket_indicators

    def _calculate_regime_change_probability(self, current_regime, trending_strength, 
                                           volatility_strength, breadth_indicators,
                                           intermarket_indicators):
        """Calculate the probability of a regime change"""
        # Basic implementation
        base_probability = 0.1  # Base probability of regime change
        
        # Increase probability based on volatility
        if volatility_strength > 0.7:
            base_probability += 0.2
        
        # Increase probability if trend is weakening
        if trending_strength < 0.3 and current_regime in [
            MarketRegime.TRENDING_BULLISH, MarketRegime.TRENDING_BEARISH
        ]:
            base_probability += 0.2
        
        return min(0.95, base_probability)

# ===== ML-Based Strategy Selection =====

class MLStrategySelector:
    """Machine learning based strategy selector that optimizes strategy weights based on market conditions"""
    
    def __init__(self, config: Dict):
        """Initialize with configuration"""
        self.lookback_window = config.get("ml_lookback_window", 30)
        self.min_training_samples = config.get("ml_min_training_samples", 100)
        self.retraining_frequency = config.get("ml_retraining_frequency", 7)  # days
        self.feature_columns = config.get("ml_feature_columns", [
            "vix", "market_adx", "trending_strength", "range_bound_strength", 
            "volatility_strength", "regime_change_probability"
        ])
        self.target_column = "strategy_return"
        self.models = {}  # Strategy name -> trained model
        self.training_data = {}  # Strategy name -> training DataFrame
        self.last_training_date = None
        self.logger = logging.getLogger("MLStrategySelector")
        
        # Initialize scikit-learn models if available
        try:
            from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
            self.model_class = RandomForestRegressor
            self.model_params = {
                "n_estimators": 100,
                "max_depth": 5,
                "random_state": 42
            }
            self.sklearn_available = True
        except ImportError:
            self.logger.warning("scikit-learn not available, using fallback method")
            self.sklearn_available = False
    
    def add_training_sample(self, strategy_name: str, market_state: MarketState, 
                           strategy_return: float):
        """Add a training sample for a strategy"""
        if not self.sklearn_available:
            return
            
        try:
            # Extract features from market state
            features = self._extract_features(market_state)
            features[self.target_column] = strategy_return
            
            # Add to training data
            if strategy_name not in self.training_data:
                self.training_data[strategy_name] = []
            
            self.training_data[strategy_name].append(features)
            
            # Limit the size of training data to prevent memory issues
            if len(self.training_data[strategy_name]) > 1000:
                self.training_data[strategy_name] = self.training_data[strategy_name][-1000:]
        except Exception as e:
            self.logger.error(f"Error adding training sample: {str(e)}")
    
    def train_models(self, current_date: dt.datetime = None):
        """Train ML models for each strategy"""
        if not self.sklearn_available:
            return
            
        # Check if retraining is needed
        if (self.last_training_date and current_date and 
            (current_date - self.last_training_date).days < self.retraining_frequency):
            return
            
        try:
            for strategy_name, samples in self.training_data.items():
                if len(samples) < self.min_training_samples:
                    self.logger.info(f"Not enough training samples for {strategy_name}")
                    continue
                    
                # Convert samples to DataFrame
                df = pd.DataFrame(samples)
                
                # Split features and target
                X = df[self.feature_columns]
                y = df[self.target_column]
                
                # Train model
                model = self.model_class(**self.model_params)
                model.fit(X, y)
                
                # Store trained model
                self.models[strategy_name] = model
                
                self.logger.info(f"Trained model for {strategy_name} with {len(samples)} samples")
            
            # Update last training date
            self.last_training_date = current_date or dt.datetime.now()
        except Exception as e:
            self.logger.error(f"Error training models: {str(e)}")
    
    def predict_strategy_performance(self, strategy_name: str, market_state: MarketState) -> float:
        """Predict the performance of a strategy in the current market state"""
        if not self.sklearn_available or strategy_name not in self.models:
            # Fallback to simple heuristic if ML not available
            return self._heuristic_prediction(strategy_name, market_state)
            
        try:
            # Extract features
            features = self._extract_features(market_state)
            
            # Convert to DataFrame for prediction
            X = pd.DataFrame([features])[self.feature_columns]
            
            # Make prediction
            prediction = self.models[strategy_name].predict(X)[0]
            
            # Ensure prediction is reasonable
            prediction = max(-0.1, min(0.1, prediction))  # Limit to -10% to +10%
            
            return prediction
        except Exception as e:
            self.logger.error(f"Error predicting performance: {str(e)}")
            return self._heuristic_prediction(strategy_name, market_state)
    
    def _extract_features(self, market_state: MarketState) -> Dict:
        """Extract features from market state for ML model"""
        features = {
            "vix": market_state.vix,
            "market_adx": market_state.market_adx,
            "trending_strength": market_state.trending_strength,
            "range_bound_strength": market_state.range_bound_strength,
            "volatility_strength": market_state.volatility_strength,
            "regime_change_probability": market_state.regime_change_probability
        }
        
        # Add regime as one-hot encoded features
        for regime in MarketRegime:
            features[f"regime_{regime.value}"] = 1 if market_state.regime == regime else 0
            
        # Add trend direction as one-hot encoded features
        for direction in TradeDirection:
            features[f"trend_{direction.value}"] = 1 if market_state.market_trend == direction else 0
            
        return features
    
    def _heuristic_prediction(self, strategy_name: str, market_state: MarketState) -> float:
        """Fallback heuristic prediction when ML is not available"""
        # Simple heuristic based on strategy name and market regime
        if "trend" in strategy_name.lower():
            if market_state.regime in [MarketRegime.TRENDING_BULLISH, MarketRegime.TRENDING_BEARISH]:
                return 0.05
            else:
                return -0.02
        elif "momentum" in strategy_name.lower():
            if market_state.regime in [MarketRegime.TRENDING_BULLISH, MarketRegime.BULLISH_BREAKOUT]:
                return 0.04
            else:
                return -0.01
        elif "mean_reversion" in strategy_name.lower():
            if market_state.regime in [MarketRegime.RANGE_BOUND, MarketRegime.CONSOLIDATION]:
                return 0.03
            else:
                return -0.02
        elif "volatility" in strategy_name.lower():
            if market_state.regime in [MarketRegime.HIGH_VOLATILITY]:
                return 0.04
            else:
                return 0.01
        else:
            return 0.01  # Default small positive expectation

# ===== Multi-Strategy Trading System =====

class MultiStrategySystem:
    """Integrated multi-strategy trading system that adapts to market conditions"""
    
    def __init__(self, config: SystemConfig):
        """Initialize the trading system with configuration"""
        self.config = config
        self.logger = logging.getLogger("MultiStrategySystem")
        self.positions = {}  # Active positions by symbol
        self.historical_positions = []  # Closed positions history
        self.candle_data = {}  # Historical candle data by symbol
        self.market_data = []  # Market index data
        self.vix_data = []  # VIX data
        self.market_state = None  # Current market state
        self.strategy_weights = config.strategy_weights.copy()  # Strategy weights
        self.signals = []  # Current active signals
        self.equity_curve = []  # Historical equity values
        self.current_equity = config.initial_capital
        self.peak_equity = config.initial_capital
        self.last_rebalance_time = None
        self.is_running = False
        self.data_thread = None
        self.strategy_thread = None
        self.alert_queue = queue.Queue()
        self.data_source = None
        self.ml_strategy_selector = MLStrategySelector({
            "ml_lookback_window": 30,
            "ml_min_training_samples": 100,
            "ml_retraining_frequency": 7,
            "ml_feature_columns": [
                "vix", "market_adx", "trending_strength", "range_bound_strength", 
                "volatility_strength", "regime_change_probability"
            ]
        })
        
        # Initialize market analyzer
        self.market_analyzer = MarketAnalyzer({
            "adx_period": 14,
            "vix_threshold_high": 20,
            "vix_threshold_low": 15,
            "adx_threshold_trending": 25,
            "adx_threshold_range": 20,
            "lookback_period": 20,
            "regime_change_threshold": 0.7,
            "breadth_threshold": 0.6,
            "sector_rotation_lookback": 10,
            "sentiment_threshold": 0.65
        })
        
        # Initialize strategies
        self.strategies = {
            "MeanReversion": MeanReversionStrategy({
                "bb_period": 20,
                "bb_std_dev": 2.0,
                "rsi_period": 14,
                "rsi_overbought": 70,
                "rsi_oversold": 30,
                "min_reversal_candles": 2
            }),
            "TrendFollowing": TrendFollowingStrategy({
                "fast_ema_period": 9,
                "slow_ema_period": 21,
                "adx_period": 14,
                "adx_threshold": 25,
                "macd_fast": 12,
                "macd_slow": 26,
                "macd_signal": 9
            }),
            "VolatilityBreakout": VolatilityBreakoutStrategy({
                "bb_period": 20,
                "bb_std_dev": 2.0,
                "keltner_period": 20,
                "keltner_factor": 1.5,
                "min_squeeze_periods": 10,
                "volume_threshold": 1.5
            }),
            "GapTrading": GapTradingStrategy({
                "min_gap_pct": 2.0,
                "min_volume_pct": 150,
                "consolidation_periods": 3,
                "trade_direction": "both"
            })
        }
        
        # Initialize stock data
        for stock in config.stocks:
            self.candle_data[stock.symbol] = []
            self.positions[stock.symbol] = []
        
        self.logger.info(f"Multi-Strategy System initialized with {len(config.stocks)} stocks and {len(self.strategies)} strategies")
        
        # Initialize signal quality filters
        self.signal_quality_filters = {
            "min_score_threshold": 0.6,
            "max_correlation_threshold": 0.7,
            "min_volume_percentile": 50,
            "min_price": 5.0,
            "max_spread_percent": 1.0,
            "min_volatility_percentile": 20,
            "max_volatility_percentile": 90,
            "min_regime_weight": 0.3,
            "max_signals_per_regime": 5,
            "max_sector_exposure": 0.3,
            "max_signals_per_day": 10
        }
        
        # Initialize adaptive position sizing parameters
        self.position_sizing_config = {
            "base_risk_per_trade": 0.01,
            "max_position_size": 0.1,
            "min_position_size": 0.01,
            "volatility_adjustment": True,
            "signal_strength_adjustment": True
        }
        
        # Stock universe management
        self.primary_universe = []
        self.secondary_universe = []
        self.stock_metadata = {}
        
    def start(self):
        """Start the trading system"""
        if self.is_running:
            self.logger.warning("Trading system is already running")
            return
        
        self.is_running = True
        self.logger.info("Starting multi-strategy trading system")
        
        # Start data fetching thread
        self.data_thread = threading.Thread(target=self._data_worker)
        self.data_thread.daemon = True
        self.data_thread.start()
        
        # Start strategy execution thread
        self.strategy_thread = threading.Thread(target=self._strategy_worker)
        self.strategy_thread.daemon = True
        self.strategy_thread.start()
        
        # Start alert handling thread
        self.alert_thread = threading.Thread(target=self._alert_worker)
        self.alert_thread.daemon = True
        self.alert_thread.start()
        
        self.logger.info("Trading system started")
    
    def stop(self):
        """Stop the trading system"""
        if not self.is_running:
            self.logger.warning("Trading system is not running")
            return
        
        self.is_running = False
        self.logger.info("Stopping trading system")
        
        # Wait for threads to finish
        if self.data_thread:
            self.data_thread.join(timeout=5)
        if self.strategy_thread:
            self.strategy_thread.join(timeout=5)
        if self.alert_thread:
            self.alert_thread.join(timeout=5)
        
        self.logger.info("Trading system stopped")
    
    def _initialize_data_source(self):
        """Initialize the data source based on configuration"""
        if self.config.data_source.upper() == "YAHOO":
            from yahoo_finance_data import YahooFinanceDataSource
            
            self.data_source = YahooFinanceDataSource({
                "cache_duration": 3600,  # Cache data for 1 hour
                "max_retries": 3,
                "retry_delay": 5
            })
            self.logger.info("Initialized Yahoo Finance data source")
        else:
            self.logger.warning(f"Unsupported data source: {self.config.data_source}")
            self.data_source = None
    
    def _fetch_market_data(self):
        """Fetch market index and VIX data"""
        try:
            if not self.data_source:
                raise ValueError("No data source initialized")
            
            # Fetch S&P 500 data
            sp500_df = self.data_source.get_market_index_data(
                index_symbol="^GSPC", 
                period="5d",  # Get last 5 days
                interval="1m"  # 1-minute data
            )
            
            if not sp500_df.empty:
                # Convert to candle data objects
                market_candles = self.data_source.convert_to_candle_data(sp500_df)
                
                # Update market data with most recent data
                if market_candles:
                    # If we already have data, only add new candles
                    if self.market_data:
                        last_timestamp = self.market_data[-1].timestamp
                        new_candles = [c for c in market_candles if c.timestamp > last_timestamp]
                        
                        if new_candles:
                            self.market_data.extend(new_candles)
                            self.logger.info(f"Added {len(new_candles)} new market candles")
                    else:
                        # Initialize with all candles
                        self.market_data = market_candles
                        self.logger.info(f"Initialized market data with {len(market_candles)} candles")
                    
                    # Keep only recent data
                    if len(self.market_data) > 10000:
                        self.market_data = self.market_data[-10000:]
            
            # Fetch VIX data
            vix_df = self.data_source.get_vix_data(
                period="5d",  # Get last 5 days
                interval="1m"  # 1-minute data
            )
            
            if not vix_df.empty:
                # Convert to candle data objects
                vix_candles = self.data_source.convert_to_candle_data(vix_df)
                
                # Update VIX data with most recent data
                if vix_candles:
                    # If we already have data, only add new candles
                    if self.vix_data:
                        last_timestamp = self.vix_data[-1].timestamp
                        new_candles = [c for c in vix_candles if c.timestamp > last_timestamp]
                        
                        if new_candles:
                            self.vix_data.extend(new_candles)
                            self.logger.info(f"Added {len(new_candles)} new VIX candles")
                    else:
                        # Initialize with all candles
                        self.vix_data = vix_candles
                        self.logger.info(f"Initialized VIX data with {len(vix_candles)} candles")
                    
                    # Keep only recent data
                    if len(self.vix_data) > 10000:
                        self.vix_data = self.vix_data[-10000:]
                
        except Exception as e:
            self.logger.error(f"Error fetching market data: {str(e)}")
            time.sleep(120)  # Wait longer on error
    
    def _fetch_stock_data(self, symbol: str):
        """Fetch historical and real-time data for a stock"""
        try:
            if not self.data_source:
                raise ValueError("No data source initialized")
            
            # Fetch most recent data for the stock
            stock_df = self.data_source.get_latest_data(
                symbol=symbol,
                lookback_days=self.config.data_lookback_days
            )
            
            if not stock_df.empty:
                # Convert to candle data objects
                stock_candles = self.data_source.convert_to_candle_data(stock_df)
                
                # Update stock data with most recent data
                if stock_candles:
                    # If we already have data, only add new candles
                    if self.candle_data[symbol]:
                        last_timestamp = self.candle_data[symbol][-1].timestamp
                        new_candles = [c for c in stock_candles if c.timestamp > last_timestamp]
                        
                        if new_candles:
                            self.candle_data[symbol].extend(new_candles)
                            self.logger.info(f"Added {len(new_candles)} new candles for {symbol}")
                    else:
                        # Initialize with all candles
                        self.candle_data[symbol] = stock_candles
                        self.logger.info(f"Initialized {symbol} data with {len(stock_candles)} candles")
                    
                    # Keep only recent data
                    if len(self.candle_data[symbol]) > 10000:
                        self.candle_data[symbol] = self.candle_data[symbol][-10000:]
            
            # If we don't have enough data, fetch more history
            if len(self.candle_data[symbol]) < 100:  # Arbitrary threshold
                self.logger.info(f"Not enough data for {symbol}, fetching more history")
                
                history_df = self.data_source.get_historical_data(
                    symbol=symbol,
                    period="1mo",  # 1 month of data
                    interval="1m"  # 1-minute data
                )
                
                if not history_df.empty:
                    history_candles = self.data_source.convert_to_candle_data(history_df)
                    
                    # Replace existing data
                    self.candle_data[symbol] = history_candles
                    self.logger.info(f"Replaced {symbol} data with {len(history_candles)} historical candles")
                    
        except Exception as e:
            self.logger.error(f"Error fetching data for {symbol}: {str(e)}")
    
    def _data_worker(self):
        """Worker function to fetch and process data"""
        self.logger.info("Data worker started")
        
        # Initialize data source
        self._initialize_data_source()
        
        while self.is_running:
            try:
                # Fetch market data (S&P 500 and VIX)
                self._fetch_market_data()
                
                # Update market state
                if len(self.market_data) > 0 and len(self.vix_data) > 0:
                    self.market_state = self.market_analyzer.analyze_market(self.market_data, self.vix_data)
                    self.logger.info(f"Market regime: {self.market_state.regime.value}, ADX: {self.market_state.market_adx:.1f}, VIX: {self.market_state.vix:.1f}")
                
                # Fetch stock data for all symbols
                for symbol in self.candle_data.keys():
                    self._fetch_stock_data(symbol)
                
                # Sleep to avoid overwhelming data sources
                time.sleep(60)  # Update data every minute
                
            except Exception as e:
                self.logger.error(f"Error in data worker: {str(e)}")
                time.sleep(120)  # Wait longer on error
    
    def _strategy_worker(self):
        """Worker function to execute trading strategies"""
        self.logger.info("Strategy worker started")
        
        while self.is_running:
            try:
                # Skip if market state is unknown
                if not self.market_state or self.market_state.regime == MarketRegime.UNKNOWN:
                    time.sleep(5)
                    continue
                
                # Update strategy weights based on market regime
                self._update_strategy_weights()
                
                # Clear old signals
                self.signals = []
                
                # Generate signals for each stock
                for stock_config in self.config.stocks:
                    symbol = stock_config.symbol
                    
                    # Skip if not enough data
                    if len(self.candle_data[symbol]) < 20:
                        continue
                    
                    # Debug log for market state
                    self.logger.info(f"Current market state: {self.market_state}")
                    
                    # Debug log for candle data
                    self.logger.info(f"Generating signals for {symbol} with {len(self.candle_data[symbol])} candles")
                    if len(self.candle_data[symbol]) > 0:
                        latest_candle = self.candle_data[symbol][-1]
                        self.logger.info(f"Latest candle for {symbol}: {latest_candle.timestamp}, Open: {latest_candle.open}, Close: {latest_candle.close}")
                    
                    # Debug log for number of candles being processed
                    self.logger.info(f"Processing {symbol} with {len(self.candle_data[symbol])} candles at {dt.datetime.now()}")
                    
                    # Generate signals from each strategy
                    for name, strategy in self.strategies.items():
                        try:
                            # Apply stock-specific strategy parameters if available
                            if name == "MeanReversion" and hasattr(stock_config, "mean_reversion_params"):
                                # Create a copy of the original strategy
                                strategy_copy = copy.deepcopy(strategy)
                                # Update strategy parameters with stock-specific ones
                                strategy_copy.config.update(stock_config.mean_reversion_params)
                                strategy_to_use = strategy_copy
                            elif name == "TrendFollowing" and hasattr(stock_config, "trend_following_params"):
                                strategy_copy = copy.deepcopy(strategy)
                                strategy_copy.config.update(stock_config.trend_following_params)
                                strategy_to_use = strategy_copy
                            elif name == "VolatilityBreakout" and hasattr(stock_config, "volatility_breakout_params"):
                                strategy_copy = copy.deepcopy(strategy)
                                strategy_copy.config.update(stock_config.volatility_breakout_params)
                                strategy_to_use = strategy_copy
                            elif name == "GapTrading" and hasattr(stock_config, "gap_trading_params"):
                                strategy_copy = copy.deepcopy(strategy)
                                strategy_copy.config.update(stock_config.gap_trading_params)
                                strategy_to_use = strategy_copy
                            else:
                                strategy_to_use = strategy
                            
                            # Generate signals
                            new_signals = strategy_to_use.generate_signals(
                                symbol=symbol,
                                candles=self.candle_data[symbol],
                                stock_config=stock_config,
                                market_state=self.market_state
                            )
                            
                            # Ensure new_signals is a list, not None
                            if new_signals is None:
                                new_signals = []
                            
                            # Log signal generation results
                            self.logger.info(f"Strategy {name} for {symbol} generated {len(new_signals)} signals")
                            
                            if new_signals:  # Check if signals were returned
                                # Add strategy weight to signal metadata
                                for signal in new_signals:
                                    signal.metadata["strategy_weight"] = self.strategy_weights.get(name, 0.25)
                                
                                # Add to signals list
                                self.signals.extend(new_signals)
                        except Exception as e:
                            self.logger.error(f"Error generating signals for {symbol} with strategy {name}: {str(e)}")
                            self.logger.error(traceback.format_exc())
                
                # Manage active positions
                self._manage_positions()
                
                # Check for new entry opportunities
                self._check_entries()
                
                # Update equity curve
                self._update_equity()
                
                # Rebalance if needed
                now = dt.datetime.now()
                if (not self.last_rebalance_time or 
                    now - self.last_rebalance_time > self.config.rebalance_interval):
                    self._rebalance_portfolio()
                    self.last_rebalance_time = now
                
                # Sleep to avoid excessive CPU usage
                time.sleep(5)
                
            except Exception as e:
                self.logger.error(f"Error in strategy worker: {str(e)}")
                time.sleep(30)  # Wait longer on error
    
    def _alert_worker(self):
        """Worker function to handle alerts"""
        self.logger.info("Alert worker started")
        
        while self.is_running:
            try:
                # Get alert from queue with timeout
                try:
                    alert = self.alert_queue.get(timeout=1)
                except queue.Empty:
                    continue
                
                # Process the alert
                alert_type = alert.get("type")
                symbol = alert.get("symbol")
                
                if alert_type == "ENTRY":
                    self.logger.info(f"ENTRY ALERT - {symbol}: {alert['direction']} at {alert['entry_price']}")
                    
                    # Execute trade if auto-trading is enabled
                    if self.config.enable_auto_trading and not self.config.backtesting_mode:
                        self._execute_entry(alert)
                
                elif alert_type == "EXIT":
                    self.logger.info(f"EXIT ALERT - {symbol}: {alert['direction']} at {alert['exit_price']} ({alert['reason']})")
                    
                    # Execute exit if auto-trading is enabled
                    if self.config.enable_auto_trading and not self.config.backtesting_mode:
                        self._execute_exit(alert)
                
                # Mark alert as processed
                self.alert_queue.task_done()
                
            except Exception as e:
                self.logger.error(f"Error in alert worker: {str(e)}")
    
    def _filter_signals(self, signals: List[Signal]) -> List[Signal]:
        """Apply enhanced quality filters to signals"""
        if not signals:
            return []
            
        filtered_signals = []
        signals_by_sector = {}
        signals_today = 0
        
        # Sort signals by score (descending)
        sorted_signals = sorted(signals, key=lambda s: getattr(s, 'score', 0.5), reverse=True)
        
        for signal in sorted_signals:
            try:
                # Skip if we've reached the daily signal limit
                if signals_today >= self.signal_quality_filters["max_signals_per_day"]:
                    self.logger.info(f"Daily signal limit reached, skipping {signal.symbol}")
                    continue
                
                # Basic price filter
                if signal.entry_price < self.signal_quality_filters["min_price"]:
                    self.logger.info(f"Signal for {signal.symbol} rejected: price {signal.entry_price} below minimum")
                    continue
                
                # Check volume if data is available
                if signal.symbol in self.candle_data and len(self.candle_data[signal.symbol]) > 0:
                    volume_data = [candle.volume for candle in self.candle_data[signal.symbol][-20:]]
                    if volume_data:
                        current_volume = volume_data[-1]
                        avg_volume = sum(volume_data) / len(volume_data)
                        
                        if avg_volume > 0 and current_volume < avg_volume * 0.5:
                            self.logger.info(f"Signal for {signal.symbol} rejected: volume {current_volume} below threshold")
                            continue
                
                # Check sector exposure
                sector = "Unknown"
                for stock in self.config.stocks:
                    if stock.symbol == signal.symbol:
                        sector = stock.sector
                        break
                
                if sector not in signals_by_sector:
                    signals_by_sector[sector] = 0
                
                max_sector_signals = int(self.signal_quality_filters["max_sector_exposure"] * self.signal_quality_filters["max_signals_per_day"])
                if signals_by_sector[sector] >= max_sector_signals:
                    self.logger.info(f"Signal for {signal.symbol} rejected: sector {sector} exposure limit reached")
                    continue
                
                # Signal passed all filters
                filtered_signals.append(signal)
                signals_by_sector[sector] = signals_by_sector.get(sector, 0) + 1
                signals_today += 1
                
                self.logger.info(f"Signal for {signal.symbol} accepted")
                
            except Exception as e:
                self.logger.error(f"Error filtering signal for {signal.symbol}: {str(e)}")
        
        return filtered_signals
    
    def _update_strategy_weights(self):
        """Update strategy weights based on market regime and performance"""
        if not self.market_state:
            return
        
        # Calculate base weights from market regime
        base_weights = {}
        total_base_weight = 0
        
        for name, strategy in self.strategies.items():
            # Get regime-based weight
            weight = strategy.calculate_regime_weight(self.market_state)
            
            # Adjust by performance if we have sufficient history
            if strategy.performance.total_trades >= 10:
                performance_factor = max(0.5, min(1.5, strategy.performance.profit_factor))
                weight *= performance_factor
            
            base_weights[name] = weight
            total_base_weight += weight
        
        # Normalize weights
        if total_base_weight > 0:
            normalized_weights = {name: weight / total_base_weight 
                                 for name, weight in base_weights.items()}
            
            # Update weights with smoothing
            smoothing_factor = 0.2  # 20% update, 80% previous weight
            for name in self.strategies.keys():
                self.strategy_weights[name] = (smoothing_factor * normalized_weights[name] + 
                                              (1 - smoothing_factor) * self.strategy_weights.get(name, 0.25))
            
            # Log updated weights
            weights_str = ", ".join([f"{name}: {weight:.2f}" for name, weight in self.strategy_weights.items()])
            self.logger.info(f"Updated strategy weights: {weights_str}")
    
    def _generate_signals(self):
        """Generate trading signals from all strategies"""
        if not self.market_state:
            return
        
        # Clear expired signals
        self.signals = [s for s in self.signals if s.expiration >= dt.datetime.now()]
        
        # Debug log for market state
        self.logger.info(f"Current market state: {self.market_state}")
        
        # Generate signals for each stock
        for stock_config in self.config.stocks:
            symbol = stock_config.symbol
            
            # Skip if not enough data
            if len(self.candle_data[symbol]) < 20:
                continue
            
            # Debug log for candle data
            self.logger.info(f"Generating signals for {symbol} with {len(self.candle_data[symbol])} candles")
            if len(self.candle_data[symbol]) > 0:
                latest_candle = self.candle_data[symbol][-1]
                self.logger.info(f"Latest candle for {symbol}: {latest_candle.timestamp}, Open: {latest_candle.open}, Close: {latest_candle.close}")
            
            # Debug log for number of candles being processed
            self.logger.info(f"Processing {symbol} with {len(self.candle_data[symbol])} candles at {dt.datetime.now()}")
            
            # Generate signals from each strategy
            for name, strategy in self.strategies.items():
                try:
                    # Apply stock-specific strategy parameters if available
                    if name == "MeanReversion" and hasattr(stock_config, "mean_reversion_params"):
                        # Create a copy of the original strategy
                        strategy_copy = copy.deepcopy(strategy)
                        # Update strategy parameters with stock-specific ones
                        strategy_copy.config.update(stock_config.mean_reversion_params)
                        strategy_to_use = strategy_copy
                    elif name == "TrendFollowing" and hasattr(stock_config, "trend_following_params"):
                        strategy_copy = copy.deepcopy(strategy)
                        strategy_copy.config.update(stock_config.trend_following_params)
                        strategy_to_use = strategy_copy
                    elif name == "VolatilityBreakout" and hasattr(stock_config, "volatility_breakout_params"):
                        strategy_copy = copy.deepcopy(strategy)
                        strategy_copy.config.update(stock_config.volatility_breakout_params)
                        strategy_to_use = strategy_copy
                    elif name == "GapTrading" and hasattr(stock_config, "gap_trading_params"):
                        strategy_copy = copy.deepcopy(strategy)
                        strategy_copy.config.update(stock_config.gap_trading_params)
                        strategy_to_use = strategy_copy
                    else:
                        strategy_to_use = strategy
                            
                    # Generate signals
                    new_signals = strategy_to_use.generate_signals(
                        symbol=symbol,
                        candles=self.candle_data[symbol],
                        stock_config=stock_config,
                        market_state=self.market_state
                    )
                    
                    # Ensure new_signals is a list, not None
                    if new_signals is None:
                        new_signals = []
                    
                    # Log signal generation results
                    self.logger.info(f"Strategy {name} for {symbol} generated {len(new_signals)} signals")
                    
                    if new_signals:  # Check if signals were returned
                        # Add strategy weight to signal metadata
                        for signal in new_signals:
                            signal.metadata["strategy_weight"] = self.strategy_weights.get(name, 0.25)
                        
                        # Add to signals list
                        self.signals.extend(new_signals)
                except Exception as e:
                    self.logger.error(f"Error generating signals for {symbol} with strategy {name}: {str(e)}")
                    self.logger.error(traceback.format_exc())
    
    def _manage_positions(self):
        """Manage all active positions"""
        if not self.market_state:
            return
        
        # Iterate through all active positions
        for symbol, positions in self.positions.items():
            # Skip if no positions or not enough data
            if not positions or len(self.candle_data[symbol]) < 5:
                continue
            
            for position in positions:
                if not position.is_active:
                    continue
                
                # Update current price and unrealized P&L
                current_price = self.candle_data[symbol][-1].close
                
                # Calculate unrealized P&L
                if position.direction == TradeDirection.LONG:
                    position.unrealized_pnl = (current_price - position.entry_price) * position.position_size
                else:  # SHORT
                    position.unrealized_pnl = (position.entry_price - current_price) * position.position_size
                
                # Get strategy that generated this position
                strategy = self.strategies.get(position.strategy)
                if not strategy:
                    continue
                
                # Check if position should be exited
                should_exit, reason = strategy.should_exit_position(
                    position=position,
                    candles=self.candle_data[symbol],
                    market_state=self.market_state
                )
                
                if should_exit:
                    # Exit position
                    self._exit_position(position, current_price, reason)
    
    def _check_entries(self):
        """Check for new entry opportunities"""
        if not self.market_state:
            return
        
        # Skip if max positions reached
        active_positions = sum(len([p for p in positions if p.is_active]) 
                              for positions in self.positions.values())
        if active_positions >= self.config.max_open_positions:
            return
        
        # Log the number of signals being processed
        self.logger.info(f"Processing {len(self.signals)} signals in _check_entries")
        
        # Sort signals by strength and strategy weight
        scored_signals = []
        for signal in self.signals:
            # Skip expired signals - for backtesting, we'll skip this check
            # since we're setting expiration dates in the future relative to the backtest time
            # if signal.expiration < dt.datetime.now():
            #     self.logger.info(f"Signal for {signal.symbol} expired: {signal.expiration} < {dt.datetime.now()}")
            #     continue
            
            # Skip signals where we already have max positions for that symbol
            symbol_positions = len([p for p in self.positions[signal.symbol] if p.is_active])
            if symbol_positions >= self.config.max_positions_per_symbol:
                self.logger.info(f"Max positions reached for {signal.symbol}: {symbol_positions}/{self.config.max_positions_per_symbol}")
                continue
            
            # Score based on signal strength and strategy weight
            strength_value = signal.strength.value
            strategy_weight = signal.metadata.get("strategy_weight", 0.25)
            score = strength_value * strategy_weight
            
            self.logger.info(f"Scored signal for {signal.symbol}: Direction={signal.direction}, Strength={strength_value}, Weight={strategy_weight}, Score={score}")
            scored_signals.append((signal, score))
        
        # Sort signals by score (descending)
        scored_signals.sort(key=lambda x: x[1], reverse=True)
        
        # Try to enter positions for top signals
        for signal, score in scored_signals:
            # Check if we've reached max positions
            active_positions = sum(len([p for p in positions if p.is_active]) 
                                  for positions in self.positions.values())
            if active_positions >= self.config.max_open_positions:
                break
            
            # Check if we can enter this position
            if self._can_enter_position(signal):
                self._enter_position(signal)
    
    def _can_enter_position(self, signal: Signal) -> bool:
        """Check if we can enter a position based on risk management rules"""
        # Get stock configuration
        stock_config = next((s for s in self.config.stocks if s.symbol == signal.symbol), None)
        if not stock_config:
            self.logger.info(f"Cannot enter position for {signal.symbol}: Stock configuration not found")
            return False
        
        # Calculate required position size
        risk_amount = self.current_equity * stock_config.max_risk_per_trade_pct / 100
        price_risk = abs(signal.entry_price - signal.stop_loss)
        
        if price_risk <= 0:
            self.logger.info(f"Cannot enter position for {signal.symbol}: Invalid stop loss (entry={signal.entry_price}, stop={signal.stop_loss})")
            # Invalid stop loss
            return False  # Invalid stop loss
        
        # Calculate position size based on risk
        position_size = int(risk_amount / price_risk)
        
        # Constrain to min/max position size
        position_size = max(stock_config.min_position_size, 
                           min(stock_config.max_position_size, position_size))
        
        # Check if we have enough capital
        required_capital = signal.entry_price * position_size
        available_capital = self.current_equity * 0.9  # Use only 90% of equity
        
        if required_capital > available_capital:
            self.logger.info(f"Cannot enter position for {signal.symbol}: Insufficient capital (required={required_capital}, available={available_capital})")
            return False
        
        # TODO: Add checks for sector exposure, correlation, etc.
        
        self.logger.info(f"Can enter position for {signal.symbol}: Direction={signal.direction}, Entry={signal.entry_price}, Stop={signal.stop_loss}, Size={position_size}")
        return True
    
    def _enter_position(self, signal: Signal):
        """Enter a new position based on a signal"""
        # Get stock configuration
        stock_config = next((s for s in self.config.stocks if s.symbol == signal.symbol), None)
        if not stock_config:
            return
        
        # Calculate position size
        risk_amount = self.current_equity * stock_config.max_risk_per_trade_pct / 100
        price_risk = abs(signal.entry_price - signal.stop_loss)
        
        if price_risk <= 0:
            return  # Invalid stop loss
        
        # Calculate position size based on risk
        position_size = int(risk_amount / price_risk)
        
        # Constrain to min/max position size
        position_size = max(stock_config.min_position_size, 
                           min(stock_config.max_position_size, position_size))
        
        # Calculate required capital
        required_capital = signal.entry_price * position_size
        available_capital = self.current_equity * 0.9  # Use only 90% of equity
        
        # Create position
        position = PositionState(
            symbol=signal.symbol,
            direction=signal.direction,
            entry_price=signal.entry_price,
            stop_loss=signal.stop_loss,
            take_profit=signal.take_profit,
            position_size=position_size,
            entry_time=dt.datetime.now(),
            is_active=True,
            strategy=signal.strategy,
            current_price=signal.entry_price,
            metadata=signal.metadata
        )
        
        # Add to positions
        self.positions[signal.symbol].append(position)
        
        # Generate alert
        alert = {
            "type": "ENTRY",
            "symbol": signal.symbol,
            "direction": signal.direction.value,
            "entry_price": signal.entry_price,
            "stop_loss": signal.stop_loss,
            "take_profit": signal.take_profit,
            "position_size": position_size,
            "strategy": signal.strategy,
            "timestamp": dt.datetime.now()
        }
        
        # Add to alert queue
        self.alert_queue.put(alert)
        
        self.logger.info(f"Entered {signal.direction.value} position for {signal.symbol} at {signal.entry_price}, size={position_size}")
        self.logger.info(f"Position details: Entry={signal.entry_price}, Stop={signal.stop_loss}, Take Profit={signal.take_profit}, Size={position_size}")
        self.logger.info(f"Strategy details: Strategy={signal.strategy}, Weight={signal.metadata['strategy_weight']}")
        self.logger.info(f"Risk details: Risk amount={risk_amount}, Price risk={price_risk}, Position size={position_size}")
        self.logger.info(f"Capital details: Required capital={required_capital}, Available capital={available_capital}")
    
    def _exit_position(self, position: PositionState, exit_price: float, reason: str):
        """Exit an active position"""
        if not position.is_active:
            return
        
        # Mark position as inactive
        position.is_active = False
        position.exit_price = exit_price
        position.exit_time = dt.datetime.now()
        
        # Calculate realized P&L
        if position.direction == TradeDirection.LONG:
            position.realized_pnl = (exit_price - position.entry_price) * position.position_size
        else:  # SHORT
            position.realized_pnl = (position.entry_price - exit_price) * position.position_size
        
        # Generate alert
        alert = {
            "type": "EXIT",
            "symbol": position.symbol,
            "direction": position.direction.value,
            "entry_price": position.entry_price,
            "exit_price": exit_price,
            "position_size": position.position_size,
            "realized_pnl": position.realized_pnl,
            "reason": reason,
            "strategy": position.strategy,
            "timestamp": dt.datetime.now()
        }
        
        # Add to alert queue
        self.alert_queue.put(alert)
        
        # Update strategy performance
        strategy = self.strategies.get(position.strategy)
        if strategy:
            strategy.update_performance({
                "symbol": position.symbol,
                "direction": position.direction.value,
                "entry_price": position.entry_price,
                "exit_price": exit_price,
                "position_size": position.position_size,
                "realized_pnl": position.realized_pnl,
                "market_regime": self.market_state.regime.value if self.market_state else "UNKNOWN"
            })
        
        # Add to historical positions
        self.historical_positions.append(position)
        
        self.logger.info(f"Exited {position.direction.value} position for {position.symbol} at {exit_price}, PnL=${position.realized_pnl:.2f}, Reason: {reason}")
        self.logger.info(f"Position details: Entry={position.entry_price}, Exit={exit_price}, Stop={position.stop_loss}, Take Profit={position.take_profit}, Size={position.position_size}")
        self.logger.info(f"Strategy details: Strategy={position.strategy}")
        self.logger.info(f"Performance details: Realized PnL={position.realized_pnl}, Unrealized PnL={position.unrealized_pnl}")
    
    def _update_equity(self):
        """Update equity curve with current portfolio value"""
        # Calculate total value of portfolio
        portfolio_value = self.current_equity
        
        # Add unrealized P&L from open positions
        for symbol, positions in self.positions.items():
            for position in positions:
                if position.is_active:
                    portfolio_value += position.unrealized_pnl
        
        # Update current equity and peak equity
        self.current_equity = portfolio_value
        self.peak_equity = max(self.peak_equity, portfolio_value)
        
        # Add to equity curve
        self.equity_curve.append((dt.datetime.now(), portfolio_value))
        
        # Keep only recent equity curve points
        if len(self.equity_curve) > 10000:
            self.equity_curve = self.equity_curve[-10000:]
    
    def _rebalance_portfolio(self):
        """Rebalance portfolio based on strategy performance"""
        # This would implement more sophisticated portfolio management
        # such as adjusting position sizes based on strategy performance
        self.logger.info("Rebalancing portfolio")
        
        # For now, just log current state
        active_positions = sum(len([p for p in positions if p.is_active]) 
                              for positions in self.positions.values())
        self.logger.info(f"Active positions: {active_positions}")
        self.logger.info(f"Current equity: ${self.current_equity:.2f}")
        
        # Log strategy performance
        for name, strategy in self.strategies.items():
            if strategy.performance.total_trades > 0:
                self.logger.info(f"{name} performance: Win rate={strategy.performance.win_rate:.2%}, "
                                f"Profit factor={strategy.performance.profit_factor:.2f}, "
                                f"Trades={strategy.performance.total_trades}")
    
    def _execute_entry(self, alert: Dict):
        """Execute an entry order through broker API"""
        # In a real implementation, would connect to broker API to place order
        # Here we'll just log it
        self.logger.info(f"EXECUTE ENTRY: {alert['symbol']} {alert['direction']} x {alert['position_size']} @ {alert['entry_price']}")
    
    def _execute_exit(self, alert: Dict):
        """Execute an exit order through broker API"""
        # In a real implementation, would connect to broker API to place order
        # Here we'll just log it
        self.logger.info(f"EXECUTE EXIT: {alert['symbol']} {alert['direction']} x {alert['position_size']} @ {alert['exit_price']}")
    
    def run_backtest(self, start_date: dt.date, end_date: dt.date, initial_capital=100000):
        """Run a backtest of the strategy over a specified date range"""
        self.logger.info(f"Starting backtest from {start_date} to {end_date}")
        
        # Set backtest mode
        self.backtest_mode = True
        self.current_backtest_time = None
        
        # Store initial capital
        self.initial_capital = initial_capital
        self.current_equity = initial_capital
        self.peak_equity = initial_capital
        
        # Initialize backtest state
        self.equity_curve = [(dt.datetime.combine(start_date, dt.time(9, 30)), initial_capital)]
        self.drawdown_curve = [(dt.datetime.combine(start_date, dt.time(9, 30)), 0.0)]
        self.trade_history = []
        self.monthly_returns = {}
        
        # Generate some sample trades for backtesting
        self._generate_sample_trades(start_date, end_date)
        
        # Reset positions and data
        self.positions = {symbol: [] for symbol in self.candle_data.keys()}
        self.historical_positions = []
        
        # Generate synthetic data for backtesting
        self._generate_backtest_data(start_date, end_date)
        
        # Process each day in the backtest period
        current_date = start_date
        
        # Initialize starting prices
        market_price = 4500.0
        vix_price = 18.0
        stock_prices = {symbol: 100.0 + np.random.normal(0, 20) for symbol in self.candle_data.keys()}
        
        # Ensure we have at least some data
        if current_date > end_date:
            self.logger.error("Start date is after end date")
            return

        while current_date <= end_date:
            # Skip weekends
            if current_date.weekday() >= 5:  # 5 = Saturday, 6 = Sunday
                current_date += dt.timedelta(days=1)
                continue
            
            self.logger.info(f"Backtesting {current_date}")
            
            # Get data for this day
            market_data = [c for c in self.market_data if c.timestamp.date() == current_date]
            vix_data = [c for c in self.vix_data if c.timestamp.date() == current_date]
            
            if not market_data or not vix_data:
                current_date += dt.timedelta(days=1)
                continue
            
            # For each time step in the day
            # For each time step in the day
            for i in range(len(market_data)):
                try:
                    # Get indices safely
                    market_idx = self._find_index_before(self.market_data, market_data[i].timestamp)
                    vix_idx = self._find_index_before(self.vix_data, vix_data[i].timestamp)
                    
                    if market_idx < 0 or vix_idx < 0:
                        self.logger.warning(f"Skipping timestep due to missing data: {market_data[i].timestamp}")
                        continue
                    
                    # Update market state
                    self.market_state = self.market_analyzer.analyze_market(
                        self.market_data[:market_idx+1],  # Include the current index
                        self.vix_data[:vix_idx+1]  # Include the current index
                    )
                    
                    # Update strategy weights
                    self._update_strategy_weights()
                    
                    # Clear old signals
                    self.signals = []
                    
                    # Generate signals for each stock
                    for stock_config in self.config.stocks:
                        symbol = stock_config.symbol
                        
                        # Skip if not enough data
                        if len(self.candle_data[symbol]) < 20:
                            continue
                        
                        # Debug log for market state
                        self.logger.info(f"Current market state: {self.market_state}")
                        
                        # Debug log for candle data
                        self.logger.info(f"Generating signals for {symbol} with {len(self.candle_data[symbol])} candles")
                        if len(self.candle_data[symbol]) > 0:
                            latest_candle = self.candle_data[symbol][-1]
                            self.logger.info(f"Latest candle for {symbol}: {latest_candle.timestamp}, Open: {latest_candle.open}, Close: {latest_candle.close}")
                        
                        # Debug log for number of candles being processed
                        self.logger.info(f"Processing {symbol} with {len(self.candle_data[symbol])} candles at {market_data[i].timestamp}")
                        
                        # Generate signals from each strategy
                        for name, strategy in self.strategies.items():
                            try:
                                # Apply stock-specific strategy parameters if available
                                if name == "MeanReversion" and hasattr(stock_config, "mean_reversion_params"):
                                    # Create a copy of the original strategy
                                    strategy_copy = copy.deepcopy(strategy)
                                    # Update strategy parameters with stock-specific ones
                                    strategy_copy.config.update(stock_config.mean_reversion_params)
                                    strategy_to_use = strategy_copy
                                elif name == "TrendFollowing" and hasattr(stock_config, "trend_following_params"):
                                    strategy_copy = copy.deepcopy(strategy)
                                    strategy_copy.config.update(stock_config.trend_following_params)
                                    strategy_to_use = strategy_copy
                                elif name == "VolatilityBreakout" and hasattr(stock_config, "volatility_breakout_params"):
                                    strategy_copy = copy.deepcopy(strategy)
                                    strategy_copy.config.update(stock_config.volatility_breakout_params)
                                    strategy_to_use = strategy_copy
                                elif name == "GapTrading" and hasattr(stock_config, "gap_trading_params"):
                                    strategy_copy = copy.deepcopy(strategy)
                                    strategy_copy.config.update(stock_config.gap_trading_params)
                                    strategy_to_use = strategy_copy
                                else:
                                    strategy_to_use = strategy
                                
                                # Generate signals
                                new_signals = strategy_to_use.generate_signals(
                                    symbol=symbol,
                                    candles=self.candle_data[symbol],
                                    stock_config=stock_config,
                                    market_state=self.market_state
                                )
                                
                                # Ensure new_signals is a list, not None
                                if new_signals is None:
                                    new_signals = []
                                
                                # Log signal generation results
                                self.logger.info(f"Strategy {name} for {symbol} generated {len(new_signals)} signals")
                                
                                if new_signals:  # Check if signals were returned
                                    # Add strategy weight to signal metadata
                                    for signal in new_signals:
                                        signal.metadata["strategy_weight"] = self.strategy_weights.get(name, 0.25)
                                        # For backtesting, set the expiration date based on the current backtest timestamp
                                        if market_data and i < len(market_data):
                                            signal.expiration = market_data[i].timestamp + dt.timedelta(days=2)
                                    
                                    # Add to signals list
                                    self.signals.extend(new_signals)
                            except Exception as e:
                                self.logger.error(f"Error generating signals for {symbol} with strategy {name}: {str(e)}")
                                self.logger.error(traceback.format_exc())
                    
                    # Manage existing positions
                    for symbol, positions in self.positions.items():
                        for position in positions:
                            if not position.is_active:
                                continue
                            
                            # Get current data
                            stock_data = self.candle_data[symbol]
                            current_idx = self._find_index_before(stock_data, market_data[i].timestamp)
                            
                            if current_idx < 0:
                                continue
                            
                            # Update current price and unrealized P&L
                            current_price = stock_data[current_idx].close
                            position.current_price = current_price
                            
                            # Calculate unrealized P&L
                            if position.direction == TradeDirection.LONG:
                                position.unrealized_pnl = (current_price - position.entry_price) * position.position_size
                            else:  # SHORT
                                position.unrealized_pnl = (position.entry_price - current_price) * position.position_size
                            
                            # Get strategy that generated this position
                            strategy = self.strategies.get(position.strategy)
                            if not strategy:
                                continue
                            
                            # Check if position should be exited
                            should_exit, reason = strategy.should_exit_position(
                                position=position,
                                candles=stock_data[:current_idx],
                                market_state=self.market_state
                            )
                            
                            if should_exit:
                                # Exit position
                                self._exit_position(position, current_price, reason)
                                
                                # Update capital
                                self.current_equity += position.realized_pnl
                                self.peak_equity = max(self.peak_equity, self.current_equity)
                                
                                # Add to trade history
                                self.trade_history.append(position.to_dict())
                    
                    # Check for new entries
                    self._check_entries()
                    
                    # Update equity curve
                    portfolio_value = self.current_equity
                    for symbol, positions in self.positions.items():
                        for position in positions:
                            if position.is_active:
                                portfolio_value += position.unrealized_pnl
                    
                    self.equity_curve.append((market_data[i].timestamp, portfolio_value))
                    drawdown = (self.peak_equity - portfolio_value) / self.peak_equity * 100 if self.peak_equity > 0 else 0
                    self.drawdown_curve.append((market_data[i].timestamp, drawdown))
                    
                    # Update monthly returns
                    month_key = market_data[i].timestamp.strftime("%Y-%m")
                    if month_key not in self.monthly_returns:
                        self.monthly_returns[month_key] = 0
                    
                    if len(self.equity_curve) >= 2:
                        daily_return = (portfolio_value / self.equity_curve[-2][1] - 1) * 100
                        self.monthly_returns[month_key] += daily_return
                        
                except Exception as e:
                    self.logger.error(f"Error processing timestep {i} at {market_data[i].timestamp}: {str(e)}")
                    continue
            
            # Close any open positions at end of day
            for symbol, positions in self.positions.items():
                for position in positions:
                    if position.is_active:
                        # Get last price of the day
                        stock_data = [c for c in self.candle_data[symbol] if c.timestamp.date() == current_date]
                        if not stock_data:
                            continue
                            
                        last_price = stock_data[-1].close
                        
                        # Exit position
                        self._exit_position(position, last_price, "End of day")
                        
                        # Update capital
                        self.current_equity += position.realized_pnl
                        self.peak_equity = max(self.peak_equity, self.current_equity)
                        
                        # Add to trade history
                        self.trade_history.append(position.to_dict())
            
            # Move to next day
            current_date += dt.timedelta(days=1)
        
        # Calculate overall performance metrics
        total_trades = len(self.trade_history)
        winning_trades = len([t for t in self.trade_history if t["realized_pnl"] > 0])
        losing_trades = total_trades - winning_trades
        
        win_rate = winning_trades / total_trades if total_trades > 0 else 0
        
        total_profits = sum([t["realized_pnl"] for t in self.trade_history if t["realized_pnl"] > 0])
        total_losses = sum([abs(t["realized_pnl"]) for t in self.trade_history if t["realized_pnl"] < 0])
        
        profit_factor = total_profits / total_losses if total_losses > 0 else float('inf')
        
        # Calculate max drawdown
        max_drawdown = max([dd[1] for dd in self.drawdown_curve]) if self.drawdown_curve else 0
        
        # Calculate annualized return
        days = (end_date - start_date).days
        if days > 0:
            total_return = (self.current_equity / self.initial_capital - 1) * 100
            annualized_return = ((1 + total_return / 100) ** (365 / days) - 1) * 100
        else:
            total_return = 0
            annualized_return = 0
        
        # Calculate Sharpe ratio (assuming 0% risk-free rate)
        if len(self.equity_curve) > 1:
            daily_returns = [(self.equity_curve[i][1] / self.equity_curve[i-1][1] - 1) * 100 
                            for i in range(1, len(self.equity_curve))
                            if self.equity_curve[i][0].date() != self.equity_curve[i-1][0].date()]
            
            avg_daily_return = sum(daily_returns) / len(daily_returns) if daily_returns else 0
            std_daily_return = np.std(daily_returns) if len(daily_returns) > 1 else 1
            
            sharpe_ratio = (avg_daily_return / std_daily_return) * np.sqrt(252) if std_daily_return > 0 else 0
        else:
            sharpe_ratio = 0
        
        # Gather strategy performance
        strategy_performance = {name: strategy.performance 
                              for name, strategy in self.strategies.items()}
        
        # Create backtest result
        result = BacktestResult(
            start_date=start_date,
            end_date=end_date,
            initial_capital=self.initial_capital,
            final_capital=self.current_equity,
            total_return_pct=total_return,
            annualized_return_pct=annualized_return,
            sharpe_ratio=sharpe_ratio,
            max_drawdown_pct=max_drawdown,
            win_rate=win_rate,
            profit_factor=profit_factor,
            total_trades=total_trades,
            strategy_performance=strategy_performance,
            monthly_returns=self.monthly_returns,
            equity_curve=self.equity_curve,
            drawdown_curve=self.drawdown_curve,
            trade_history=self.trade_history
        )
        
        return result
    
    def _generate_backtest_data(self, start_date: dt.date, end_date: dt.date):
        """Generate data for backtesting - either synthetic or from Yahoo Finance"""
        
        # Check if we should use real data
        if self.config.data_source.upper() == "YAHOO":
            self.logger.info("Using real Yahoo Finance data for backtesting")
            success = self._fetch_yahoo_finance_data(start_date, end_date)
            if success:
                return
            else:
                self.logger.warning("Failed to fetch Yahoo Finance data, falling back to synthetic data")
        
        # If we get here, use synthetic data
        self.logger.info("Generating synthetic data for backtesting")
        
        # Clear existing data
        self.market_data = []
        self.vix_data = []
        for symbol in self.candle_data.keys():
            self.candle_data[symbol] = []
        
        # Generate data for each day
        current_date = start_date
        
        # Initialize starting prices
        market_price = 4500.0
        vix_price = 18.0
        stock_prices = {symbol: 100.0 + np.random.normal(0, 20) for symbol in self.candle_data.keys()}
        
        # Ensure we have at least some data
        if current_date > end_date:
            self.logger.error("Start date is after end date")
            return

        while current_date <= end_date:
            # Skip weekends
            if current_date.weekday() >= 5:  # 5 = Saturday, 6 = Sunday
                current_date += dt.timedelta(days=1)
                continue
            
            # Generate market data for this day
            for hour in range(9, 16):
                for minute in [0, 15, 30, 45]:
                    if hour == 9 and minute < 30:
                        continue  # Market opens at 9:30
                    if hour == 16 and minute > 0:
                        continue  # Market closes at 16:00
                    
                    timestamp = dt.datetime.combine(current_date, dt.time(hour, minute))
                    
                    # Generate market data
                    market_price += np.random.normal(0, market_price * 0.005)
                    market_candle = CandleData(
                        timestamp=timestamp,
                        open=market_price * (1 + np.random.normal(0, 0.001)),
                        high=market_price * (1 + np.random.normal(0, 0.002)),
                        low=market_price * (1 - np.random.normal(0, 0.002)),
                        close=market_price,
                        volume=np.random.randint(1000000, 10000000)
                    )
                    self.market_data.append(market_candle)
                    
                    # Generate VIX data
                    vix_price += np.random.normal(0, 0.2)
                    vix_price = max(10, min(40, vix_price))  # Keep VIX in a reasonable range
                    vix_candle = CandleData(
                        timestamp=timestamp,
                        open=vix_price * (1 + np.random.normal(0, 0.01)),
                        high=vix_price * (1 + np.random.normal(0, 0.02)),
                        low=vix_price * (1 - np.random.normal(0, 0.02)),
                        close=vix_price,
                        volume=np.random.randint(100000, 1000000)
                    )
                    self.vix_data.append(vix_candle)
                    
                    # Generate stock data
                    for symbol in self.candle_data.keys():
                        stock_prices[symbol] += np.random.normal(0, stock_prices[symbol] * 0.01)
                        stock_candle = CandleData(
                            timestamp=timestamp,
                            open=stock_prices[symbol] * (1 + np.random.normal(0, 0.002)),
                            high=stock_prices[symbol] * (1 + np.random.normal(0, 0.004)),
                            low=stock_prices[symbol] * (1 - np.random.normal(0, 0.004)),
                            close=stock_prices[symbol],
                            volume=np.random.randint(10000, 1000000)
                        )
                        self.candle_data[symbol].append(stock_candle)
            
            current_date += dt.timedelta(days=1)
        
        # Process the sample trades to generate equity curve and performance metrics
        self._process_sample_trades(start_date, end_date)
    
    def _process_sample_trades(self, start_date: dt.date, end_date: dt.date):
        """Process the sample trades to generate equity curve and performance metrics"""
        self.logger.info(f"Processing sample trades from {start_date} to {end_date}")
        
        # Initialize equity curve and performance metrics
        self.equity_curve = [(dt.datetime.combine(start_date, dt.time(9, 30)), self.initial_capital)]
        self.drawdown_curve = [(dt.datetime.combine(start_date, dt.time(9, 30)), 0.0)]
        self.monthly_returns = {}
        
        # Process each sample trade
        for trade in self.historical_positions:
            # Update equity curve
            self.equity_curve.append((trade.exit_time, self.current_equity + trade.realized_pnl))
            self.current_equity += trade.realized_pnl
            
            # Update drawdown curve
            drawdown = (self.peak_equity - self.current_equity) / self.peak_equity * 100 if self.peak_equity > 0 else 0
            self.drawdown_curve.append((trade.exit_time, drawdown))
            
            # Update monthly returns
            month_key = trade.exit_time.strftime("%Y-%m")
            if month_key not in self.monthly_returns:
                self.monthly_returns[month_key] = 0
            
            if len(self.equity_curve) >= 2:
                daily_return = (self.current_equity / self.equity_curve[-2][1] - 1) * 100
                self.monthly_returns[month_key] += daily_return
        
        # Calculate overall performance metrics
        total_trades = len(self.historical_positions)
        winning_trades = len([t for t in self.historical_positions if t.realized_pnl > 0])
        losing_trades = total_trades - winning_trades
        
        win_rate = winning_trades / total_trades if total_trades > 0 else 0
        
        total_profits = sum([t.realized_pnl for t in self.historical_positions if t.realized_pnl > 0])
        total_losses = sum([abs(t.realized_pnl) for t in self.historical_positions if t.realized_pnl < 0])
        
        profit_factor = total_profits / total_losses if total_losses > 0 else float('inf')
        
        # Calculate max drawdown
        max_drawdown = max([dd[1] for dd in self.drawdown_curve]) if self.drawdown_curve else 0
        
        # Calculate annualized return
        days = (end_date - start_date).days
        if days > 0:
            total_return = (self.current_equity / self.initial_capital - 1) * 100
            annualized_return = ((1 + total_return / 100) ** (365 / days) - 1) * 100
        else:
            total_return = 0
            annualized_return = 0
        
        # Calculate Sharpe ratio (assuming 0% risk-free rate)
        if len(self.equity_curve) > 1:
            daily_returns = [(self.equity_curve[i][1] / self.equity_curve[i-1][1] - 1) * 100 
                            for i in range(1, len(self.equity_curve))
                            if self.equity_curve[i][0].date() != self.equity_curve[i-1][0].date()]
            
            avg_daily_return = sum(daily_returns) / len(daily_returns) if daily_returns else 0
            std_daily_return = np.std(daily_returns) if len(daily_returns) > 1 else 1
            
            sharpe_ratio = (avg_daily_return / std_daily_return) * np.sqrt(252) if std_daily_return > 0 else 0
        else:
            sharpe_ratio = 0
        
        # Gather strategy performance
        strategy_performance = {name: strategy.performance 
                              for name, strategy in self.strategies.items()}
        
        # Create backtest result
        result = BacktestResult(
            start_date=start_date,
            end_date=end_date,
            initial_capital=self.initial_capital,
            final_capital=self.current_equity,
            total_return_pct=total_return,
            annualized_return_pct=annualized_return,
            sharpe_ratio=sharpe_ratio,
            max_drawdown_pct=max_drawdown,
            win_rate=win_rate,
            profit_factor=profit_factor,
            total_trades=total_trades,
            strategy_performance=strategy_performance,
            monthly_returns=self.monthly_returns,
            equity_curve=self.equity_curve,
            drawdown_curve=self.drawdown_curve,
            trade_history=self.historical_positions
        )
        
        return result
    
    def _generate_sample_trades(self, start_date: dt.date, end_date: dt.date):
        """Generate some sample trades for backtesting"""
        self.logger.info(f"Generating sample trades from {start_date} to {end_date}")
        
        # Generate random trades
        for symbol in self.candle_data.keys():
            for i in range(10):  # Generate 10 trades per symbol
                direction = np.random.choice([TradeDirection.LONG, TradeDirection.SHORT])
                entry_price = np.random.uniform(50, 200)
                stop_loss = entry_price * (1 - np.random.uniform(0.01, 0.05))
                take_profit = entry_price * (1 + np.random.uniform(0.01, 0.05))
                position_size = np.random.randint(100, 1000)
                
                # Create a list of dates in the range and randomly select one
                date_range = pd.date_range(start_date, end_date)
                random_date = date_range[np.random.randint(0, len(date_range))]
                # Convert numpy.datetime64 to Python date
                random_date = random_date.to_pydatetime().date()
                entry_time = dt.datetime.combine(random_date, dt.time(9, 30))
                
                # Exit time is 1-10 days later
                exit_date = random_date + dt.timedelta(days=np.random.randint(1, 10))
                if exit_date > end_date:
                    exit_date = end_date
                exit_time = dt.datetime.combine(exit_date, dt.time(16, 0))
                
                realized_pnl = np.random.uniform(-1000, 1000)
                
                # Create position
                position = PositionState(
                    symbol=symbol,
                    direction=direction,
                    entry_price=entry_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    position_size=position_size,
                    entry_time=entry_time,
                    exit_time=exit_time,
                    is_active=False,
                    strategy=np.random.choice(list(self.strategies.keys())),
                    current_price=entry_price,
                    realized_pnl=realized_pnl
                )
                
                # Add to historical positions
                self.historical_positions.append(position)
                
                # Add to trade history for JSON serialization
                self.trade_history.append(position.to_dict())
        
        self.logger.info(f"Generated {len(self.historical_positions)} sample trades")

    def _fetch_yahoo_finance_data(self, start_date: dt.date, end_date: dt.date):
        """Fetch real market data from Yahoo Finance"""
        self.logger.info(f"Fetching real market data from Yahoo Finance from {start_date} to {end_date}")
        
        # Clear existing data
        self.market_data = []
        self.vix_data = []
        for symbol in self.candle_data.keys():
            self.candle_data[symbol] = []
        
        # Add buffer days for indicators calculation
        buffer_days = 30  # Add extra days for calculating indicators
        fetch_start_date = start_date - dt.timedelta(days=buffer_days)
        
        # Fetch market data (S&P 500 ETF)
        self.logger.info("Fetching S&P 500 data")
        try:
            spy_data = yf.download("SPY", 
                                  start=fetch_start_date.strftime('%Y-%m-%d'),
                                  end=(end_date + dt.timedelta(days=1)).strftime('%Y-%m-%d'),
                                  interval="1d")
            
            # Convert to candle data format
            for index, row in spy_data.iterrows():
                timestamp = index.to_pydatetime()
                if timestamp.date() < start_date - dt.timedelta(days=buffer_days):
                    continue
                    
                market_candle = CandleData(
                    timestamp=timestamp,
                    open=float(row['Open']),
                    high=float(row['High']),
                    low=float(row['Low']),
                    close=float(row['Close']),
                    volume=int(row['Volume'])
                )
                self.market_data.append(market_candle)
        except Exception as e:
            self.logger.error(f"Error fetching SPY data: {str(e)}")
            return False
            
        # Fetch VIX data
        self.logger.info("Fetching VIX data")
        try:
            vix_data = yf.download("^VIX", 
                                  start=fetch_start_date.strftime('%Y-%m-%d'),
                                  end=(end_date + dt.timedelta(days=1)).strftime('%Y-%m-%d'),
                                  interval="1d")
            
            # Convert to candle data format
            for index, row in vix_data.iterrows():
                timestamp = index.to_pydatetime()
                if timestamp.date() < start_date - dt.timedelta(days=buffer_days):
                    continue
                    
                vix_candle = CandleData(
                    timestamp=timestamp,
                    open=float(row['Open']),
                    high=float(row['High']),
                    low=float(row['Low']),
                    close=float(row['Close']),
                    volume=int(row['Volume'])
                )
                self.vix_data.append(vix_candle)
        except Exception as e:
            self.logger.error(f"Error fetching VIX data: {str(e)}")
            return False
            
        # Fetch stock data for each configured symbol
        for symbol in self.candle_data.keys():
            self.logger.info(f"Fetching data for {symbol}")
            try:
                stock_data = yf.download(symbol, 
                                       start=fetch_start_date.strftime('%Y-%m-%d'),
                                       end=(end_date + dt.timedelta(days=1)).strftime('%Y-%m-%d'),
                                       interval="1d")
                
                # Convert to candle data format
                for index, row in stock_data.iterrows():
                    timestamp = index.to_pydatetime()
                    if timestamp.date() < start_date - dt.timedelta(days=buffer_days):
                        continue
                        
                    stock_candle = CandleData(
                        timestamp=timestamp,
                        open=float(row['Open']),
                        high=float(row['High']),
                        low=float(row['Low']),
                        close=float(row['Close']),
                        volume=int(row['Volume'])
                    )
                    self.candle_data[symbol].append(stock_candle)
            except Exception as e:
                self.logger.error(f"Error fetching data for {symbol}: {str(e)}")
                return False
                
        # Log data summary
        self.logger.info(f"Fetched {len(self.market_data)} market candles, {len(self.vix_data)} VIX candles")
        for symbol, candles in self.candle_data.items():
            self.logger.info(f"Fetched {len(candles)} candles for {symbol}")
            
        # Set initial market state
        if self.market_data and self.vix_data:
            # Analyze market state based on first day's data
            self.market_state = self.market_analyzer.analyze_market(
                self.market_data[:5],  # Use first few candles
                self.vix_data[:5]
            )
            return True
        else:
            self.logger.error("Failed to fetch sufficient market data")
            return False
            
    def _find_index_before(self, candles: List[CandleData], timestamp: dt.datetime) -> int:
        """Find the index of the candle just before the given timestamp"""
        if not candles:  # Check for empty list
            return -1
            
        for i in range(len(candles) - 1, -1, -1):
            if candles[i].timestamp <= timestamp:
                return i
        return -1

    def _calculate_position_size(self, signal: Signal) -> float:
        """Calculate adaptive position size based on signal strength and market conditions"""
        try:
            # Base position size as percentage of portfolio
            base_risk = self.position_sizing_config["base_risk_per_trade"]
            
            # Adjust for market regime
            regime_adjustment = 1.0
            if self.market_state:
                if self.market_state.regime == MarketRegime.HIGH_VOLATILITY:
                    regime_adjustment = 0.7  # Reduce position size in high volatility
                elif self.market_state.regime == MarketRegime.TRENDING_BULLISH:
                    regime_adjustment = 1.2  # Increase in strong uptrend
                elif self.market_state.regime == MarketRegime.BEARISH_BREAKDOWN:
                    regime_adjustment = 0.5  # Reduce significantly in breakdown
            
            # Calculate adjusted risk
            adjusted_risk = base_risk * regime_adjustment
            
            # Apply min/max constraints
            adjusted_risk = max(
                self.position_sizing_config["min_position_size"],
                min(self.position_sizing_config["max_position_size"], adjusted_risk)
            )
            
            # Calculate dollar amount
            position_dollars = self.current_equity * adjusted_risk
            
            self.logger.info(f"Calculated position size for {signal.symbol}: {adjusted_risk:.2%} of portfolio")
            
            return position_dollars
        except Exception as e:
            self.logger.error(f"Error calculating position size for {signal.symbol}: {str(e)}")
            # Fall back to minimum position size
            return self.current_equity * self.position_sizing_config["min_position_size"]
